var store = [{
        "title": "1671번 - 상어의 저녁식사",
        "excerpt":"(플레티넘 III) 이분 매칭 알고리즘을 이용하여 1671번 “상어의 저녁식사”를 풀어보았다.     문제 링크      https://boj.kr/1671   풀이 알고리즘      이분 매칭 (Bipartite Matching)   깊이 우선 탐색 (Depth First Search)   풀이   이분 매칭 알고리즘을 응용하여 풀 수 있다.   각 상어를 하나의 정점으로 표현하면, 상어간의 먹이사슬 관계는 방향이 있는 간선으로 나타낼 수 있다.   이 때, 정점과 간선들로 만들 수 있는 트리의 최소 개수를 구하는 문제이다.   단, 문제에서 고려해야 할 두 가지 조건이 있다.      한 상어는 최대 두 마리의 상어만 먹을 수 있다.    각 정점마다 두 개의 정점을 매칭 시켜줘야 하므로, 정점마다 DFS를 2회 호출한다.      한 상어가 다른 상어를 잡아먹는 동안 나머지 상어들은 상어를 잡아먹을 수 없으며, 이미 잡아먹힌 상어는 다른 상어들을 잡아먹을 수 없다.    두 상어가 서로를 동시에 잡아먹을 수 없으므로, 서로 동일한 체급의 상어는 한쪽만 잡아먹힐 수 있도록 처리를 해준다.   전체 코드   import java.io.BufferedReader; import java.io.IOException; import java.io.InputStreamReader; import java.util.StringTokenizer; import java.util.Stack;   class Shark {     long size;     long speed;     long intelligence;      boolean canEat(Shark prey) {         return (this.size &gt;= prey.size                 &amp;&amp; this.speed &gt;= prey.speed                 &amp;&amp; this.intelligence &gt;= prey.intelligence);     }      boolean isEqual(Shark shark) {         return (this.size == shark.size                 &amp;&amp; this.speed == shark.speed                 &amp;&amp; this.intelligence == shark.intelligence);     } }   class Node {     Node parentNode = null;     Stack&lt;Node&gt; connectedNodes = new Stack&lt;&gt;();     boolean isMatched = false; }   public class Main {     static final int MAX_NUMBER_OF_NODES = 50;     static final int MATCHINGS_PER_NODE = 2;      static int numberOfNodes;     static Node[] nodes;       public static void main(String[] args) throws IOException {         setup();         int answer = maximumBipartiteMatching();         System.out.println(answer);     }      static void setup() throws IOException {         BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));          setupNumberOfNodes(bufferedReader);         setupNodes(bufferedReader);     }       static void setupNumberOfNodes(BufferedReader bufferedReader) throws IOException {         StringTokenizer stringTokenizer = new StringTokenizer(bufferedReader.readLine());          numberOfNodes = Integer.parseInt(stringTokenizer.nextToken());     }      static void setupNodes(BufferedReader bufferedReader) throws IOException {         Shark[] sharks = new Shark[numberOfNodes];         nodes = new Node[numberOfNodes];          for (int i = 0; i &lt; numberOfNodes; i++) {             StringTokenizer stringTokenizer = new StringTokenizer(bufferedReader.readLine());              sharks[i] = new Shark();             sharks[i].size = Long.parseLong(stringTokenizer.nextToken());             sharks[i].speed = Long.parseLong(stringTokenizer.nextToken());             sharks[i].intelligence = Long.parseLong(stringTokenizer.nextToken());              nodes[i] = new Node();             for (int j = 0; j &lt; i; j++) {                 if (sharks[i].canEat(sharks[j])) {                     nodes[i].connectedNodes.push(nodes[j]);                 }                  // 두 상어가 서로 잡아먹을 수 없도록 하기위해,                 // 동일한 체급의 상어에 대해 예외 처리.                 if (sharks[j].canEat(sharks[i]) &amp;&amp; !sharks[j].isEqual(sharks[i])) {                     nodes[j].connectedNodes.push(nodes[i]);                 }             }         }     }      static int maximumBipartiteMatching() {         int numberOfRootNodes = 0;          for (int i = 0; i &lt; numberOfNodes; i++) {             for (int j = 0; j &lt; MATCHINGS_PER_NODE; j++) {                 clearMatchings();                 matchUsingDFS(nodes[i]);             }         }          for (int i = 0; i &lt; numberOfNodes; i++) {             if (nodes[i].parentNode == null)                 numberOfRootNodes++;         }         return numberOfRootNodes;     }      static void clearMatchings() {         for (int i = 0; i &lt; numberOfNodes; i++) {             nodes[i].isMatched = false;         }     }      static boolean matchUsingDFS(Node node) {         // 매칭에 성공하면 true를 반환한다.          for (Node childNode : node.connectedNodes) {             if (childNode.isMatched)                 continue;              childNode.isMatched = true;             if (childNode.parentNode == null || matchUsingDFS(childNode.parentNode)) {                 childNode.parentNode = node;                 return true;             }         }         return false;     } }  ","categories": ["Algorithm","BAEKJOON Online Judge"],
        "tags": ["Baekjoon Online Judge","Java","Bipartite Matching"],
        "url": "/algorithm/baekjoon%20online%20judge/baekjoon-1671",
        "teaser": "https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/images/boj-og.png"
      },{
        "title": "P-NP 문제 (P versus NP problem)",
        "excerpt":"PS를 하다보면 자주 보이지만, 잘 알지 못했던 P-NP 문제란 무엇인지 알아보자.     개요   “P versus NP problem”   P-NP 문제는 복잡도 종류 P와 NP가 같은지에 대한 컴퓨터 과학의 큰 문제이다.1 “컴퓨터로 풀이법이 빠르게 확인된 문제”가 “컴퓨터로 빠르게 풀리기도 할 것인가 아닌가”를 묻는 문제이다.   설명   계산 복잡도 이론 (Computational complexity theory)   계산 복잡도 이론은 컴퓨터 과학에서 계산 이론의 분야이다.   계산 문제를 푸는 알고리즘을 복잡도에 따라 분류하는 방법을 연구한다. 이렇게 구성된 문제의 모임을 복잡도 종류라고 한다.   복잡도 종류 (Complexity class)   ‘시간 복잡도’와 ‘공간 복잡도’, ‘결정 문제’인지 여부 등2 다양한 기준에 따라 문제들을 모아놓은 집합을 복잡도 종류라고 한다.   복잡도 종류는 매우 많고 다양하지만, 그중 가장 중요한 두 가지의 종류가 바로 P 문제와 NP 문제이다.      다양한 복잡도 종류:         P 문제는 결정론적 튜링 기계가 다항공간에 풀 수 있는 결정 문제의 집합이다.     NP 문제는 확률적(비결정론적) 튜링 기계가 다항시간에 풀 수 있는 결정 문제의 집합이다.     L 문제는 결정론적 튜링 기계로 로그 메모리 공간을 사용하여 풀 수 있는 결정 문제의 집합이다.     …      결정 문제 (Decision problem)   답이 Y/N로 구분될 수 있는 문제를 결정 문제라고 한다. 예를 들어 ‘$x$는 $y$의 배수인가?’ 와 같은 질문은 결정 문제이다.   P 문제와 NP 문제는 모두 결정 문제의 분류에 해당한다.   P 문제   “Polynomial time problem”     계산 복잡도 이론에서는 다항Polynomial 시간 안에 풀 수 있는 결정 문제들을 모아 놓은 복잡도 종류를 P 문제라고 정의한다. 예를 들어 정렬 문제의 경우에는 $O(N\\log{N})$, $O(N^2)$ 등의 시간 복잡도를 갖는 다양한 정렬 알고리즘을 사용할 수 있으므로 정렬 문제는 P 문제이다.3   NP 문제   “Non-deterministic Polynomial time problem”   NP 문제는 다항 시간에 답을 검증 할 수 있는 결정 문제들의 집합이다.4 5   P=NP?   만약 문제를 푸는 다항 시간 알고리즘이 존재한다면, 이를 사용해 문제를 처음부터 다시 풀고 답을 비교해 보며 답이 옳은지를 다항시간 내에 확인할 수 있다. 즉, 모든 P 문제는 모두 NP 문제에 포함된다.      P 집합은 이미 NP 집합에 포함되기에, 모든 NP 문제가 P 문제라는 것을 증명하면 P=NP 가 된다. 여기서 P와 NP가 같은지 아닌지를 증명하는 것을 P-NP 문제라고 한다. 하지만 P와 NP가 같은지 같지 않은지는 아직 알려지지 않았다.   참고 문헌      알고리즘 문제 해결 전략 1. 구종만, 2012. 인사이트. p.121-125.   https://ko.wikipedia.org/wiki/P_(복잡도)   https://ko.wikipedia.org/wiki/NP_(복잡도)   https://ko.wikipedia.org/wiki/P-NP_문제   https://ko.wikipedia.org/wiki/결정_문제   https://ko.wikipedia.org/wiki/계산_복잡도_이론   https://ko.wikipedia.org/wiki/복잡도_종류                 밀레니엄 7대 수학 난제중 하나이다. &#8617;                  이를 계산 복잡도라고 한다. &#8617;                  같은 동작(정렬)을 수행하기 위해 버블정렬, 퀵정렬, 병합정렬 등 다양한 알고리즘을 사용할 수 있고, 이들은 다항 시간 알고리즘이다. &#8617;                  ‘답이 주어졌을 때 이것이 정답인지를 다항 시간 내에 확인할 수 있는 문제’ &#8617;                  P가 다항 시간에 풀 수 있는 문제면, NP는 다항 시간에 풀 수 없는 문제라고 착각하기 쉽다. 하지만 이는 NP의 정의와는 거리가 멀다. &#8617;           ","categories": ["Algorithm"],
        "tags": [],
        "url": "/algorithm/p-np-problem",
        "teaser": null
      },{
        "title": "시간복잡도를 배운 도도",
        "excerpt":"문제 링크: https://www.acmicpc.net/contest/problem/760/1   문제 풀이   각 라인별로 문자열 “for”과 “while”의 등장횟수를 센 뒤에, 가장 많은 등장횟수를 가진 라인의 등장횟수를 답으로 출력하면 된다.   함수로 구현할 때,     하나의 라인에 대하여 반복문의 등장 횟수를 셀 함수 countLoops()와   Stdin1 에서 입력을 받고 각 라인별 등장횟수중 최댓값을 찾을 메인함수   이렇게 크게 두 가지의 함수로 나누어 구현하면 될 것 같다.   Python 3   str.count() 이용   Python의 내장함주중 str.count()를 이용하면 어이없을 정도로 너무나도 쉽게 substring의 수를 셀 수 있다.   import sys   def solve():     answer = 0     number_of_lines = int(sys.stdin.readline())     for i in range(number_of_lines):         line = sys.stdin.readline()         answer = max(answer, count_loops(line))     print(answer)   def count_loops(line: str) -&gt; int:     return line.count(\"for\") + line.count(\"while\")   if __name__ == \"__main__\":     solve()                 표준입력 (Standard Input) &#8617;           ","categories": ["Algorithm","BAEKJOON Online Judge"],
        "tags": ["Baekjoon Online Judge","2022 ICPC Sinchon Winter Algorithm Camp Contest Open"],
        "url": "/algorithm/baekjoon%20online%20judge/baekjoon-contest-760-1",
        "teaser": "https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/images/boj-og.png"
      },{
        "title": "전체 카테고리 페이지 만들기",
        "excerpt":"이 포스트는 Minimal Mistakes 테마에서 카테고리 페이지를 추가하는 법에 대하여 다룬다.        1. 포스트 작성시 카테고리 등록   포스트 작성시 머릿말에 아래와 같이 카테고리를 등록할 수 있다. 지금 이 포스트의 카테고리 분류는 “Blog Dev”이므로 아래와 같이 머릿말을 작성하였다.   --- title: \"\" categories:   - \"Blog Dev\" ---   위와 같이 머릿말을 작성하고 나면, 아래와 같이 포스트 하단에 카테고리가 부여된 것을 알 수 있다.      2. 카테고리 페이지 생성 :: /categories/   각 포스트에 부여한 카테고리 별로 포스트를 모아놓은 페이지를 생성할 것이다.      2.1. 카테고리 페이지 주소 확인   _config.yml의 일부를 보면 아래와 같은 내용이 있다.   # Archives #  Type #  - GitHub Pages compatible archive pages built with Liquid ~&gt; type: liquid (default) #  - Jekyll Archives plugin archive pages ~&gt; type: jekyll-archives #  Path (examples) #  - Archive page should exist at path when using Liquid method or you can #    expect broken links (especially with breadcrumbs enabled) #  - &lt;base_path&gt;/tags/my-awesome-tag/index.html ~&gt; path: /tags/ #  - &lt;base_path&gt;/categories/my-awesome-category/index.html ~&gt; path: /categories/ #  - &lt;base_path&gt;/my-awesome-category/index.html ~&gt; path: / category_archive:   type: liquid   path: /categories/ tag_archive:   type: liquid   path: /tags/   💡 위에서 category_archive.path의 값을 기억하자. 기본값은 /categories/일 것이다.   2.2. _pages/   Jekyll의 폴더 구조에서 _pages/ 디렉토리 아래에는 포스트로 분류되지는 않지만1, 포스트와 같이 머릿말을 부여할 수 있는 글을 작성할 수 있다. 머릿말에 permalink 속성을 통해 주소를 부여하면, 해당 주소에서 볼 수 있는 글이 생성되는 것이다.      만약, Jekyll을 사용하고 있는 레포지토리에 _pages 폴더가 없다면 만들어주자.   2.3. _pages/categories.md 생성   카테고리 페이지를 _pages/아래 생성해보자. 파일명은 자유롭게 지어도 되나, 직관성을 위해 categories.md를 추천한다.   생성한 _pages/categories.md 파일에는 다음의 내용을 작성한다.   --- title: \"카테고리\" permalink: /categories/ layout: categories ---   💡 2.1. 에서 확인한 주소가 /categories/가 아니었다면, 해당 주소를 permalink에 적어주도록 하자.   이제 블로그에 /categories/ 주소로 들어가서 카테고리 페이지가 활성화 되어있는지 확인해보면 끝이다.                  따라서, 메인 페이지의 최신 글 목록에 나타나지 않는다. &#8617;           ","categories": ["Side Project","GitHub Blog"],
        "tags": ["Minimal Mistakes"],
        "url": "/side%20project/github%20blog/categories",
        "teaser": null
      },{
        "title": "보드게임 \"쿼리도\" 소개",
        "excerpt":"   쿼리도(Quoridor)는 2인용 턴제 전략 게임이다.   쿼리도는 규칙이 굉장히 단순하다. 플레이어들은 각자 한 개의 말(♟)을 가지며, 출발선에서부터 말을 움직여 반대쪽 끝에 먼저 도달하는 사람이 승리한다.   이 게임은 자신이 가진 장애물로 상대방의 장기말이 진격하는 것을 방해하며 먼저 승리하기 위해 심리싸움을 하는 것이 게임의 주된 재미요소이다.   게임 구성물   쿼리도를 구성하는 모든 구성품에는 다음과 같은 것들이 있다.      81개의 칸(Square)으로 구성된 게임보드(Board) x1   말(Pawn) x4   장애물(Fence) x20   승리 조건   승리 조건은 자신의 말이 출발선(BaseLine)에서 반대쪽 끝에 가장 먼저 도착하는 것이다.   게임 규칙   시작하기 전      각자 1개의 말과 10개의 장애물을 가지고 시작한다.   각 플레이어는 자신의 말을 출발선 가운데 칸에 놓는다.   시작 플레이어를 정한다.   게임   각 플레이어는 자신의 차례에 다음 중 한 가지 행동을 할 수 있다.      자기 말을 움직인다.   자신이 가진 장애물을 하나 놓는다.   말의 이동      말은 전후좌우 사방으로 한번에 한 칸만 움직일 수 있다.   말은 장애물을 통과할 수 없다.   장애물의 배치      장애물은 칸과 칸의 사이 두 공간에 딱 맞게 놓여야 한다.   플레이어는 장애물을 이용하여 상대 말의 전진을 지연시기커나 자신의 말이 쉽게 전진할 수 있도록 놓을 수 있다. 하지만 항상 모든 말이 각자의 목적지에 도착할 수 있는 길을 하나는 남겨 두어야 한다.   말끼리 마주 볼 때   두 개의 말이 서로 인접한 칸에 위치하고 있을 때, 장애물이 둘 사이를 가로막고 있지 않은 경우 상대방의 말을 뛰어넘어 이동할 수 있다. 만약 상대 말의 뒤에 장애물이 있다면, 상대 말의 왼쪽이나 오른쪽 옆으로 뛰어넘는 것도 가능하다.   게임의 종료   자신의 출발선에서 반대쪽 9칸 중 하나에 먼저 도착한 플레이어가 승리한다.   ","categories": ["Side Project"],
        "tags": ["Quoridor"],
        "url": "/side%20project/about-quoridor",
        "teaser": null
      },{
        "title": "탐욕 알고리즘 (Greedy Algorithm)",
        "excerpt":"탐욕 알고리즘, 혹은 그리디는 현재 상황에서 가장 좋아 보이는 것만 선택하는 알고리즘이다.     1. 설명   사실 어려운 설명도 따로 필요없다.   매 순간 가장 좋아보이는 것을 선택하되, 현재의 선택이 나중에 미칠 영향에 대해서는 고려하지 않는다는 것이다.   2. 사용하기 좋은 상황   탐욕 알고리즘을 쓰기 좋은 문제는 다음의 두 가지를 만족하는 문제이다.      앞의 선택이 이후의 선택에 영향을 주지 않는다.   전체적으로 최선의 선택이 부분적으로도 최선의 선택이다.   위의 조건을 만족하는 경우, 최적의 답을 찾기 좋은 알고리즘이다. 하지만 위의 조건을 만족하지 못한다면, 탐욕 알고리즘은 최적의 답이 아닌 근사적인 답을 도출할 가능성이 높아 주의해야한다.   3. 같이 보기      #greedy 문제 모음  ","categories": ["Algorithm"],
        "tags": ["Greedy"],
        "url": "/algorithm/greedy",
        "teaser": null
      },{
        "title": "1240번 - 노드사이의 거리",
        "excerpt":"(골드 V) N개의 노드로 이루어진 트리가 주어질 때, M개의 노드 쌍의 거리를 각각 구하는 문제.     문제 링크: https://boj.kr/1240   1. 플로이드 워셜? (X)   처음 문제를 읽어보고는 단순 최단경로 문제인줄 알았다. 곧바로 플로이드-워셜 알고리즘을 작성하여 풀이를 시도해보았으나 바로 시간초과를 받았다. $n=1000$ 에서 $O(N^3)$ 알고리즘은 너무 큰 욕심이었나보다.   다음은 플로이드-워셜로 풀이를 시도할 때의 코드이다.   import sys   INF = 10001 MAX_N_NODES = 1000  dist = [[INF for x in range(MAX_N_NODES+1)] for y in range(MAX_N_NODES+1)]  n, m = map(int, sys.stdin.readline().split())  for i in range(n-1):     u, v, d = map(int, sys.stdin.readline().split())     dist[u][v] = d     dist[v][u] = d  ## Floyd-Warshall for k in range(1, MAX_N_NODES+1):     for i in range(1, MAX_N_NODES+1):         for j in range(1, MAX_N_NODES+1):             dist[i][j] = min(dist[i][j], dist[i][k]+dist[k][j])  for i in range(m):     u, v = map(int, sys.stdin.readline().split())     sys.stdout.write(f'{dist[u][v]}\\n')   2. Breadth-First-Search (O)   결국 새로운 코드를 작성하였고, “맞았습니다”를 받을 수 있었다. 새로운 접근법을 찾기위해서는 문제에서 ‘트리’라고 한 것에 주목해볼 필요가 있었다.      [위키백과] 트리는 그래프의 일종으로, 여러 노드가 한 노드를 가리킬 수 없는 구조이다. 간단하게는 회로가 없고, 서로 다른 두 노드를 잇는 길이 하나뿐인 그래프를 트리라고 부른다.    어떤 노드에서 다른 노드로 갈 수 있는 길이 하나 밖에 없다면 최단 거리를 검색할 필요가 없어진다. 어차피 경로가 없지 않은 한, 어떠한 경우에도 경로는 하나 뿐일테니까.   따라서 DFS 혹은 BFS를 이용한 탐색 알고리즘을 구현해보았다. 코드는 아래와 같다.   import sys from collections import defaultdict, deque from typing import Deque, Dict, Set, Tuple   # graph[u][v] 는 u &lt;-&gt; v 사이 거리  dist: Dict[int, Dict[int, int]] = defaultdict(dict)   def bfs(src: int, dst: int) -&gt; int:     visited: Set[int] = set()     queue: Deque[Tuple[int, int]] = deque()      queue.append((src, 0))      while queue:         node, total_dist = queue.popleft()         if node == dst:             return total_dist         if node not in visited:             visited.add(node)             for child, child_dist in dist[node].items():                 queue.append((child, total_dist + child_dist))      raise ValueError   n, m = map(int, sys.stdin.readline().split())  for i in range(n-1):     u, v, d = map(int, sys.stdin.readline().split())     dist[u][v] = d     dist[v][u] = d  for i in range(m):     u, v = map(int, sys.stdin.readline().split())     sys.stdout.write(f'{bfs(u, v)}\\n')   3. 알게 된 점.      트리에서는 회로가 존재하지 않는다. (순환 경로가 없다.)   Floyd-Warshall 은 굉장히 느린 알고리즘이다.  ","categories": ["Algorithm","BAEKJOON Online Judge"],
        "tags": ["Baekjoon Online Judge","Breadth First Search"],
        "url": "/algorithm/baekjoon%20online%20judge/baekjoon-1240",
        "teaser": "https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/images/boj-og.png"
      },{
        "title": "1789번 - 수들의 합",
        "excerpt":"(실버 V) 그리디 문제 - 서로 다른 N개의 자연수의 합이 S일 때, N의 최댓값을 구하기.     문제 링크: https://boj.kr/1789   1. 풀이   서로 다른 N개의 자연수의 합이 S일 때, N의 최댓값을 구하는 문제이다.   가장 작은 수들로 합을 이루었을 때 N이 가장 클 것이므로, 가장 작은 수부터 차례로 조합을 찾아나가면 된다.   단, 19의 경우: $19=1+2+3+4+5+…$ 를 하게되면 마지막에 $4$가 남는다. 서로 다른 수만 사용할 수 있으므로 이러한 경우, 마지막에 더해진 $5$와 남은 수인 $4$를 더한 $9$가 마지막 덧셈 수가 되면된다.   2. 코드   s = int(input())  count = 0 while s &gt; 0:     count += 1     s -= count if s &lt; 0:     count -= 1  print(count)  ","categories": ["Algorithm","BAEKJOON Online Judge"],
        "tags": ["Baekjoon Online Judge","Greedy"],
        "url": "/algorithm/baekjoon%20online%20judge/baekjoon-1789",
        "teaser": "https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/images/boj-og.png"
      },{
        "title": "5585번 - 거스름돈",
        "excerpt":"(브론즈 II) 탐욕 알고리즘을 이용한 거스름돈 구하기!     문제 링크: https://boj.kr/5585   1. 풀이   현재 상황에서 가장 최선인 것을 선택하면 되는 그리디 문제이다.   가장 큰 액수의 동전부터 차례로 거슬러 줄 경우에 거슬러 줄 동전의 개수가 가장 적어진다.   2. 코드   coin_types = [500, 100, 50, 10, 5, 1]  money = 1000 - int(input()) count = 0  for coin in coin_types:     count += money // coin     money %= coin  print(count)  ","categories": ["Algorithm","BAEKJOON Online Judge"],
        "tags": ["Baekjoon Online Judge","Greedy"],
        "url": "/algorithm/baekjoon%20online%20judge/baekjoon-5585",
        "teaser": "https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/images/boj-og.png"
      },{
        "title": "사이드바에 카테고리 리스트를 자동으로 생성하기",
        "excerpt":"Minimal Mistakes 테마를 수정하여, 사이드바에 카테고리 목록과 함께 카테고리 별 포스트 수를 출력하도록 할 것이다.        1. 사이드 바 템플릿 코드 찾기   Minimal Mistakes 테마는 사이드바를 지원한다. 사이드 바에 카테고리 목록을 삽입하기 위해 가장 먼저 사이드바를 출력하는 템플릿 코드를 찾는다.   Jekyll을 사용하는 정적사이트 엔진에서는 _layouts/과 _includes/ 디렉토리에 liquid 템플릿 코드가 위치한다. 해당 디렉토리들을 위주로 사이드바 템플릿 코드를 검색해보면, _includes/sidebar.html을 찾을 수 있다.      2. 카테고리 목록을 삽입할 위치 찾기   _include/sidebar.html을 보자.   {% if page.author_profile or layout.author_profile or page.sidebar %}   &lt;div class=\"sidebar sticky\"&gt;     {% if page.author_profile or layout.author_profile %}{% include author-profile.html %}{% endif %}     {% if page.sidebar %}         {% for s in page.sidebar %}         {% if s.image %}             &lt;img src=\"{{ s.image | relative_url }}\"                 alt=\"{% if s.image_alt %}{{ s.image_alt }}{% endif %}\"&gt;         {% endif %}         {% if s.title %}&lt;h3&gt;{{ s.title }}&lt;/h3&gt;{% endif %}         {% if s.text %}{{ s.text | markdownify }}{% endif %}         {% if s.nav %}{% include nav_list nav=s.nav %}{% endif %}         {% endfor %}         {% if page.sidebar.nav %}         {% include nav_list nav=page.sidebar.nav %}         {% endif %}     {% endif %}   &lt;/div&gt; {% endif %}   &lt;div class=\"sidebar sticky\"&gt; 태그 안에 순차적으로 ‘사용자 프로필’과 ‘사이드 바’가 오는 것을 확인할 수 있다. 이 중 사이드바 영역에 카테고리 리스트를 추가하면 된다.   {% if page.sidebar %} 바로 아래 {% include sidebar__categories.html %}을 아래와 같이 삽입해주자.   ... &lt;div class=\"sidebar sticky\"&gt;   {% if page.author_profile or layout.author_profile %}{% include author-profile.html %}{% endif %}   {% if page.sidebar %}     {% include sidebar__categories.html %} &lt;!-- 새로 추가된 코드 --&gt;     {% for s in page.sidebar %} ...   3. 카테고리 리스트 템플릿 만들기   사이드 바에서 sidebar__categories.html 을 삽입하도록 했다. 하지만 이 파일은 아직 존재하지 않는 파일이므로 만들어주어야 한다. _includes/sidebar__categories.html 파일을 새로 생성하고 아래의 코드를 삽입하자.   &lt;!-- _includes/sidebar__categories.html --&gt;  {% assign categories = site.categories | sort %}  &lt;nav class=\"nav__list\"&gt;   &lt;h3 class=\"nav__title\" style=\"padding-left: 0;\"&gt;     {{ site.data.ui-text[site.locale].categories_label | default: \"Categories\" }}     &lt;label for=\"ac-categories\"&gt;{{ site.data.ui-text[site.locale].menu_label | default: \"Toggle Menu\" }}&lt;/label&gt;   &lt;/h3&gt;   &lt;input id=\"ac-categories\" name=\"accordion-categories\" type=\"checkbox\" /&gt;   &lt;ul class=\"nav__items\"&gt;     &lt;li&gt;       &lt;ul&gt;         {% for category in categories %}           {% assign title = category[0] %}           {% assign posts = category[1] %}           {% capture url %}/categories/#{{ title | slugify }}{% endcapture %}           &lt;li&gt;             &lt;a href=\"{{ url }}\"{% if url == page.url %} class=\"active\"{% endif %}&gt;               {{ title }}               &lt;span style=\"opacity: .33;\"&gt;({{posts.size}})&lt;/span&gt;             &lt;/a&gt;           &lt;/li&gt;         {% endfor %}       &lt;/ul&gt;     &lt;/li&gt;   &lt;/ul&gt; &lt;/nav&gt;   코드를 삽입한 뒤, 사이트를 다시 빌드한다. 사이드바에 카테고리가 나타나는지 확인하면 끝.      ","categories": ["Side Project","GitHub Blog"],
        "tags": ["Minimal Mistakes"],
        "url": "/side%20project/github%20blog/categories-on-sidebar",
        "teaser": null
      },{
        "title": "뉴턴 방법 (Newton–Raphson Method)",
        "excerpt":"수치 해석학에서 뉴턴 방법은은 실수값 함수의 영점을 근사하는 방법의 하나이다. 뉴턴-랍슨 방법이라고도 한다.     1. 원리              임의의 한 점 $x_0$을 선택한다.            $x_0$에서 $f(x)$의 접선을 그어 $x$ 절편 $x_1$ 을 찾는다.                       $f(x)$의 접선 : $y = f’( x_0 ) ( x - x_0 ) + f( x_0 )$                        $x$ 절편 : $x_1 = x_0 - f( x_0 ) / f’( x_0 )$                        $x_1$에서 $f(x)$의 접선을 그어 $x$ 절편 $x_2$ 을 찾는다.            $x_2$에서 $f(x)$의 접선을 그어 $x$ 절편 $x_3$ 을 찾는다.       …   $x_{n-1}$에서 $f(x)$의 접선을 그어 $x$ 절편 $x_n$ 을 찾는다.   반복횟수($n$)가 많아질 수록 점점 영점에 수렴한다.   2. 뉴턴 방법을 사용하려면      초기 가정치 $x_0$ 를 근에 충분히 가깝게 하지 않으면 수렴하지 않을 수 있다.   $f’(x_0)$ 가 $0$ 인. 즉, 접선이 수평인 $x_0$ 을 선택해서는 안된다.   3. 엄밀한 정의   연속 미분 가능 함수 $f\\colon [a,b]\\to \\mathbb {R}$ 가 영점 $\\hat {x} \\in (a,b)$ 를 갖는다고 하자. 또한, $f’({\\hat {x}}) \\neq 0$ 라고 하자. 그렇다면, 다음을 만족시키는 열린집합 $\\hat {x} \\in U \\subseteq (a,b)$ 가 존재한다.      임의의 $x_{0} \\in U$ 에 대하여, 수열 $x_{n+1} = x_{n} - f( x_{n} ) / f’( x_{n} )$, ( $n \\in {0,1,2,\\dots }$ ) 은 $\\hat {x}$로 수렴한다.   3.1. 엄밀한 정의 풀이 (시도)   사실 나는 수학과가 아니라서 저런 기호들은 아직 잘 모른다. 조금의 번역이 필요하다.           “연속 미분 가능 함수 $f\\colon [a,b]\\to \\mathbb {R}$”                       $f$ 는 연속 함수이다.                      연속함수여야 접선의 영점에서 다시 함수 값을 잡아도 중간에 끊여있지 않을 것이다.                                 $f$ 는 미분 가능 함수이다.                      아마도 하나의 $x$ 에 대해 하나의 $y = f(x)$만 있다는 뜻인 것 같다.                                 $x \\in (a, b)$ 에서 $f(x)$ 는 실수이다.                        “영점 $\\hat {x} \\in (a,b)$ 를 갖는다고 하자.”                       $\\hat {x} \\in (a, b)$ 일때, $f( \\hat {x} ) = 0$ 을 만족하는 $\\hat {x}$ 가 있다.                      영점은 $x$ 절편을 말하는 것 같다.                                 “또한, $f’({\\hat {x}}) \\neq 0$ 라고 하자.”              $\\hat {x} = 0$ 일 때, 변곡점을 갖지 않는다는 것이므로, $f(x)$는 영점의 전후에서 증감 방향이 대체로 변하지 않는다. 전체적으로 증가만 하거나 감소만 한다.          ","categories": ["Algorithm"],
        "tags": ["Newton's Method","Newton–Raphson Method"],
        "url": "/algorithm/newton-raphson-method",
        "teaser": null
      },{
        "title": "10835번 - 카드게임",
        "excerpt":"(골드 V) 두 개의 카드더미로 하는 게임에서 얻을 수 있는 최대 점수를 동적 프로그래밍과 DFS를 이용하여 풀이하였다.     문제 링크      https://boj.kr/10835   문제 요약   $2N$ 개의 카드가 주어졌다. 각 카드에는 양의 정수가 하나 적혀있고, 좌・우로 $N$개씩 두 개의 더미로 나누어 카드게임을 진행한다. 각 턴에는 아래의 행동 중 하나를 할 수 있다.      왼쪽 카드만 버린다.   양쪽 카드 모두 버린다.   *오른쪽 카드만 버린다. (오른쪽 카드의 숫자가 왼쪽보다 커야한다. 오른쪽 카드에 적힌 수를 점수로 얻는다.)   두 카드 더미 중 하나라도 빈다면 게임이 끝난다. 게임을 통해 얻을 수 있는 최대 점수를 구해야 한다.   Brute Force 이용한 풀이. (31점)   처음 문제를 보자마자 든 생각은 “그리디인가…? 아니면, 모든 케이스에 대해 시뮬레이션 해봐야 하나?” 였다. 그 생각을 함과 동시에 바로, Queue를 이용한 Brute Force무차별 대입 풀이를 먼저 시도하였다.   아래의 코드를 보면 Queue큐와 반복문을 이용한 방식으로 모든 케이스를 시뮬레이션 한다. 매 단계마다 카드 덱을 통채로 큐에 넣으면 시・공간적으로 매우 비효율적일 것이기에, 큐에는 좌우 카드 더미에서 다음에 뽑을 카드의 위치 두 곳과, 현재까지 누적된 점수만을 담았다.   from collections import deque from collections import namedtuple from typing import Deque   Node = namedtuple('Node', ['left', 'right', 'score'])  LEFT_DECK = [] RIGHT_DECK = []   def left_card(index: int) -&gt; int:     return LEFT_DECK[index]  def right_card(index: int) -&gt; int:     return RIGHT_DECK[index]  def pop_left(q: Deque, node: Node) -&gt; None:     n = Node(node.left+1, node.right, node.score)     q.append(n)  def pop_both(q: Deque, node: Node) -&gt; None:     n = Node(node.left+1, node.right+1, node.score)     q.append(n)  def pop_right(q: Deque, node: Node) -&gt; None:     if right_card(node.right) &lt; left_card(node.left):         n = Node(node.left, node.right+1, node.score+right_card(node.right))         q.append(n)   if __name__ == \"__main__\":     N = int(input())     LEFT_DECK.extend(map(int, input().split()))     RIGHT_DECK.extend(map(int, input().split()))      max_score = 0      q: Deque[Node] = deque()     q.append(Node(0,0,0))      while q:         node = q.popleft()         if N &lt;= node.left or N &lt;= node.right:             max_score = max(max_score, node.score)         else:             pop_left(q, node)             pop_both(q, node)             pop_right(q, node)      print(max_score)   이 풀이로는 좋은 시간효율을 기대하지 못한다는 것을 알고 있었지만, 생각보다 더 낮은 점수인 31/100점을 받았다.   31점을 획득했다는 것은, $1 \\leq N \\leq 10$ 에서는 이 풀이가 유효하나,  $10 \\leq N \\leq 25$ 에서는 유효하지 않다는 것이다.   시간 복잡도   걸릴 시간을 대충 추정해보자. 빅-오 표기법에서, $O(N)$ 일 때, $N = 100,000,000$ 이면 1초로 보면 된다는… 그런 느낌이 있다.   이 문제를 BF로 풀이할 경우, 매 순간 2~3개의 선택지가 있다고 생각해볼 수 있다. 그러면 대강 $O(3^N)$ 정도의 복잡도를 가지지 않을까? 그러할 경우 $N = 17$ 만 되어도 $3^N = 129,140,163$ 으로 시간 제한을 맞추기엔 어림도 없어진다. 하물며 문제의 조건에 따르면 최악의 경우 $1 \\leq N \\leq 2,000$ 이니, 절대 다른 알고리즘을 찾아야 한다.   $N = 2,000$ 이라고 볼 때, 허용 가능 한 것은  $O(N^2)$ 정도라고 생각하면 될 것 같다.   Dynamic Programming &amp; DFS - Python 3 (64점)   다음으로는 동적 프로그래밍을 통해 접근해보기로 했다. 앞서 BF로 풀이한 것과 동일한 것은, 각 카드 더미에서 뽑은 카드의 개수로 현 상태를 구분한다는 것이다. 그러나 이번에는 메모이제이션을 통해 방문체크를 할 수 있게 되어, 중복된 계산은 지양할 수 있게 된다. 최대 $N \\times N$ 회만 계산하면 되므로 시간복잡도 $O(N^2)$로 안정적이게 풀 수 있을 것으로 예상하였다.   import sys sys.setrecursionlimit(int(1e6))   N = int(input())  LEFT_DECK = list(map(int, input().split())) RIGHT_DECK = list(map(int, input().split()))   # dp[i][j] 왼쪽 카드를 i개, 오른쪽 카드를 j개 버렸을 때 얻을 수 있는 최대 점수 메모이제이션 dp = [[-1] * (N+1) for j in range((N+1))]   def simulate(left: int, right: int) -&gt; int:     if N &lt;= left or N &lt;= right:         dp[left][right] = 0      if dp[left][right] == -1:         dp[left][right] = max(dp[left][right], simulate(left+1, right))         dp[left][right] = max(dp[left][right], simulate(left+1, right+1))          if LEFT_DECK[left] &gt; RIGHT_DECK[right]:             dp[left][right] = max(dp[left][right], simulate(left, right+1)+RIGHT_DECK[right])      return dp[left][right]   print(simulate(0, 0))   이 풀이를 통해 $0 \\leq N \\leq 25$ 의 케이스는 가뿐히 통과해 64점까지 득점하였다.   하지만 역시, Python은 타언어에 비해 태생적으로 매우 느리다는 한계가 있다. Python3으로 제출 시 $0 \\leq N \\leq 2000$ 에서 시간 초과를 받았으며, PyPy3으로 제출시에는 메모리 초과를 받았다.   Dynamic Programming &amp; DFS - Java 8 (100점)   그래서 현재 어느정도 배워가는 중인 자바로 최대한 코드를 옮겨보았다.   import java.io.BufferedReader; import java.io.IOException; import java.io.InputStreamReader; import java.util.Stack; import java.util.StringTokenizer;   public class Main {     static int n;     static int[][] dp;     static Stack&lt;Integer&gt; left_deck, right_deck;      public static void main(String[] args) throws IOException {         BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));         StringTokenizer stringTokenizer = new StringTokenizer(bufferedReader.readLine());          left_deck = new Stack&lt;Integer&gt;();         right_deck = new Stack&lt;Integer&gt;();          n = Integer.parseInt(stringTokenizer.nextToken());          stringTokenizer = new StringTokenizer(bufferedReader.readLine());         for (int i = 0; i &lt; n; i++)             left_deck.push(Integer.parseInt(stringTokenizer.nextToken()));          stringTokenizer = new StringTokenizer(bufferedReader.readLine());         for (int i = 0; i &lt; n; i++)             right_deck.push(Integer.parseInt(stringTokenizer.nextToken()));          System.out.println(Integer.toString(solve()));          bufferedReader.close();     }      public static int solve() {         dp = new int[2001][2001];          for (int i = 0; i &lt; n; i++)             for (int j = 0; j &lt; n; j++)                 dp[i][j] = -1;          return _solve(0, 0);     }      private static int _solve(int i, int j) {         if (i &gt;= n || j &gt;= n)             dp[i][j] = 0;          if (dp[i][j] == -1) // If not visited         {             dp[i][j] = Math.max(dp[i][j], _solve(i + 1, j));             dp[i][j] = Math.max(dp[i][j], _solve(i + 1, j + 1));              if (left_deck.get(i) &gt; right_deck.get(j))                 dp[i][j] = Math.max(dp[i][j], _solve(i, j + 1) + right_deck.get(j));         }          return dp[i][j];     } }   느낀 점   Python 3 의 구현속도는 경이로울 정도로 빠르나, 성능은 그러하지 못하다. 이대로 PS를 계속 해나아가려면 Python으로 빠르게 알고리즘을 검증하고 다른 언어로 옮길 수 있거나, 혹은 아예 다른 언어를 숙달해둘 필요성이 있다고 느꼈다.  ","categories": ["Algorithm","BAEKJOON Online Judge"],
        "tags": ["Baekjoon Online Judge","Dynamic Programming","Depth First Search","Brute Force","Breadth First Search"],
        "url": "/algorithm/baekjoon%20online%20judge/baekjoon-10835",
        "teaser": "https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/images/boj-og.png"
      },{
        "title": "Python 에서 무한대를 표현하는 법",
        "excerpt":"Python에서 무한대를 표현하는 방법은 일반적으로, 정수로 표현하는 방법과 실수로 표현하는 방법 두 가지가 있다.     정수가 가질 수 있는 최댓값   sys.maxsize는 Python에서 int 자료형이 가질 수 있는 최댓값으로 생각 할 수 있다.   컴퓨터의 WORD 사이즈에 따라 그 크기가 다를 수 있다.      x32 운영체제에서는: $2^{32}$ (4 Bytes), (표현범위: [$-2^{31}$, $2^{31}-1$])   x64 운영체제에서는: $2^{64}$ (8 Bytes), (표현범위: [$-2^{63}$, $2^{63}-1$])   사용 방법   &gt;&gt;&gt; import sys &gt;&gt;&gt; print(sys.maxsize)  9223372036854775807  &gt;&gt;&gt; import math &gt;&gt;&gt; print(math.log2(sys.maxsize))  63.0   한계           int의 표현범위 $[-2^{63}$, $+2^{63}-1]$ 을 벗어난 숫자에 대해서는 적용할 수 없다.            Python은 기본적으로 Big Integer를 지원하기 때문에, 드물지만 위의 범위를 초과한 값을 사용하게 될 수도 있다. 따라서, sys.maxsize를 사용할 생각이라면 큰 수를 사용하는지 여부를 반드시 염두해두자.       참고자료      sys — System-specific parameters and functions — Python 3.9.6 documentation     float 클래스의 inf   float()는 Python에서 부동 소수점 자료형을 표현하기 위한 클래스이다.   float('Infinity')를 실행하면 inf라는 값이 만들어진다. 이 값을 이용하여 ‘무한’을 표현할 수 있다.   # 'Infinity'를 입력하여 inf를 만들 수 있다 &gt;&gt;&gt; float('Infinity') inf  # 'inf'를 사용할 수도 있다. &gt;&gt;&gt; float('inf') inf  # +, -부호를 적용할 수 있다. &gt;&gt;&gt; float('-inf') -inf  # 대소문자를 구분하지 않는다. &gt;&gt;&gt; float('iNfINity') inf   한계           부동 소수점의 예외 처리는 표준화가 충분히 되어있지 않다.            float형으로 선언한 변수로 큰 수를 다루게 될 경우 OverflowError가 발생 할 수 있는데, 앞서 언급한대로 예외 처리가 부실하기 때문에, 대부분의 경우 제대로 검사되지 않는다. 따라서, 만약 무한대와 더불어 큰 수를 다루게 된다면, 부동 소수점 보다는 정수 자료형을 사용하는게 좋을 것으로 보인다. (정수에 대해서는 OverflowError 대신 MemoryError가 발생하여 연산이 중단 될 수도 있다.)       참고자료      Built-in Functions — Python 3.9.6 documentation   Built-in Exceptions — Python 3.9.6 documentation  ","categories": ["Research","Others"],
        "tags": ["Python"],
        "url": "/research/others/infinity",
        "teaser": null
      },{
        "title": "개별 카테고리 페이지를 자동으로 생성하게 하였다",
        "excerpt":"2022년 3월 2일, 블로그에 카테고리 페이지를 자동으로 생성하는 기능을 추가하였다.   레이아웃은 Minimal Mistakes 테마가 기본으로 제공하는 _layout/category.html를 사용하였다. (개별 카테고리 페이지 레이아웃이 Minimal Mistakes에서 기본으로 제공하는 레이아웃 중에 있었다.)   수동으로 페이지 만들기   처음부터 자동으로 카테고리 페이지를 생성하게 한 것은 아니었다. 각 카테고리별로 페이지를 따로 만들어주었다. 당시 디렉터리 구조를 보면 아래와 같았다.   . ├── _config.yml ├── _pages/ │   ├── categories/ │   │   │   # 카테고리 별 페이지들 │   │   ├── algorithm.md │   │   ├── baekjoon-online-judge.md │   │   ├── blog-dev.md ...         └── macos.md │   ├── 404.md │   └── categories.md ...   각 카테고리 페이지를 만들 때에는 _pages/categories/카테고리_명(slugify).md 파일을 생성하고, 각 파일마다 Front matter의 layout 속성에 category를 부여했다.   --- title: Blog Dev permalink: /categories/blog-dev/ layout: category ---   이렇게 생성한 페이지는 빈 페이지이다. 그 이유는 아래 두 파일을 살펴보면 알 수 있다.      _layouts/category.html   _includes/posts-category.html   두 페이지가 주고받는 taxonomy 라는 속성에 주목해보자. 이 속성은 _includes/posts-category.html에서 site.categories[include taxonomy] 라는 구문을 통해 카테고리를 선택하는데 사용된다. 이 속성을 생성할 페이지의 머릿말에 추가해야 한다는 것을 알 수 있다.   # _pages/categories/blog-dev.md  --- title: Blog Dev permalink: /categories/blog-dev/ layout: category taxonomy: Blog Dev ---  깃헙 블로그 관련 포스트 모음입니다.    위와 같이 파일을 생성해두고 다시 bundle exec jekyll serve 명령을 실행해보면 지정한 주소에 카테고리 페이지가 생성되어 있음을 확인할 수 있다.   단, 이런식으로 각 카테고리 페이지를 직접 만들어야 한다는건 상당히 번거로운 일이다. 만약 새로운 카테고리가 생기거나 없어진다고 하면, 내가 항상 위의 카테고리 페이지들을 함께 관리해낼 수 있을까… 난 자신이 없다.   페이지 생성을 자동화할 방법 모색   내가 코딩을 좋아하는 이유는, 무지성 단순 반복 작업을 절대 귀찮아하기 때문이다. 정말 극혐이다. 그래서 카테고리 페이지 생성역시 자동화 할 방법이 없나 구색하기 시작했다.   처음에는 liquid 템플릿 언어를 이용하면 될 거라는 생각으로 시작했다. 하지만 liquid 템플릿 언어를 공부하면 할 수록 liquid의 한계를 깨달았고 다른 방법을 모색해야 한다는 결론에 다다랐다.   그러던 중, Jekyll의 공식문서에서 Generator 라는 것을 알게되었다.   Jekyll::Generator   https://jekyllrb.com/docs/plugins/generators/           Jekyll이 사용자 규칙에 따라 추가 컨텐츠를 생성하길 원한다면, generator를 만들어 사용할 수 있다.     기본적으로, Jekyll은 “_plugins/” 디렉토리에 위치하는 generator를 찾아본다.      사용자 플러그인을 통해 페이지를 생성할 수 있고, 이는 Ruby 언어로 작성하는 모양이다.   위 문서에서 소개하는 새로운 페이지를 생성하는 generator 예제를 베이스로 하여 새 플러그인을 작성하기로 하였다.   module SamplePlugin   class CategoryPageGenerator &lt; Jekyll::Generator     safe true      def generate(site)       site.categories.each do |category, posts|         site.pages &lt;&lt; CategoryPage.new(site, category, posts)       end     end   end    # Subclass of `Jekyll::Page` with custom method definitions.   class CategoryPage &lt; Jekyll::Page     def initialize(site, category, posts)       @site = site             # the current site instance.       @base = site.source      # path to the source directory.       @dir  = category         # the directory the page will reside in.        # All pages have the same filename, so define attributes straight away.       @basename = 'index'      # filename without the extension.       @ext      = '.html'      # the extension.       @name     = 'index.html' # basically @basename + @ext.        # Initialize data hash with a key pointing to all posts under current category.       # This allows accessing the list in a template via `page.linked_docs`.       @data = {         'linked_docs' =&gt; posts       }        # Look up front matter defaults scoped to type `categories`, if given key       # doesn't exist in the `data` hash.       data.default_proc = proc do |_, key|         site.frontmatter_defaults.find(relative_path, :categories, key)       end     end      # Placeholders that are used in constructing page URL.     def url_placeholders       {         :category   =&gt; @dir,         :basename   =&gt; basename,         :output_ext =&gt; output_ext,       }     end   end end   빠른 Ruby 언어 공부   우선 Ruby 언어를 간단히 공부할 필요가 있었다. 감으로 알 수 있는 건 다음과 같았다.           모듈과 클래스 개념은 이미 어느정도 익숙하다.     &lt; 기호는모종의 대입문으로 쓰이는 것 같다. (C++의 cin &gt; variable 처럼 연산자 오버라이드일 수도 있음에 유의.)     end로 블럭을 닫는 문법은 쉘 스크립트, Basic 언어 등에서 겪어보아 익숙한 것 같다.     Jekyll::Generator의 :: 은 C++의 namespace 개념과 비슷한 것 같다.     주석이 친절해 각 함수의 역할은 대충 알 것 같다.      이어서 잘 모르겠는것들을 하나씩 찾아보았다.           @가 변수명 앞에 붙으면, 이는 인스턴스 변수임을 의미한다.(참조)     =&gt; 연산자는 해쉬(딕셔너리) 자료형의 키에 값을 할당할 때 사용하는 연산자이다. (참조)      사용자 플러그인 작성   Ruby 언어를 어느정도 사용할 수는 있을 정도로 공부했다. 계속해서, 아래와 같이 사용자 플러그인을 필요에 맞게 손보았다.   @@ -1,4 +1,4 @@ - module SamplePlugin + module CategoryPageGeneratingPlugin     class CategoryPageGenerator &lt; Jekyll::Generator       safe true  @@ -24,7 +24,11 @@ def initialize(site, category, posts)       # Initialize data hash with a key pointing to all posts under current category.       # This allows accessing the list in a template via `page.linked_docs`.       @data = { -       'linked_docs' =&gt; posts +       'linked_docs' =&gt; posts, +       'title' =&gt; category, +       'layout' =&gt; 'category', +       'permalink' =&gt; 'categories/:category/', +       'taxonomy' =&gt; category,       }        # Look up front matter defaults scoped to type `categories`, if given key   이제 번거롭게 _pages/categories/카테고리_명.md 파일을 일일이 만들어주지 않아도 알아서 카테고리들이 생성된다!   …다만, 주소 패턴을 'permalink' =&gt; 'categories/:category/'로 해두어서 그런지, /categories/Baekjoon%20Online%20Judge/와 같이 못생긴 url encoded 주소로 부여되었다.   좀 더 깔끔한 slugified 스타일로 통일하고 싶어, Jekyll API를 조사해보다 관련 기능을 제공하는 메소드가 있는 것을 확인하여 코드를 조금 수정하였다.      Jekyll::Utils#slugify   @@ -14,7 +14,7 @@ class CategoryPage &lt; Jekyll::Page     def initialize(site, category, posts)       @site = site             # the current site instance.       @base = site.source      # path to the source directory. -     @dir  = category         # the directory the page will reside in. +     @dir  = Jekyll::Utils.slugify(category)         # the directory the page will reside in.        # All pages have the same filename, so define attributes straight away.       @basename = 'index'      # filename without the extension.   새로운 카테고리 페이지 주소를 적용   다음은 새로 생긴 변경사항들을 블로그 곳곳에 적용하는 디테일을 보여줄 차례이다. 다행히 변경해야 할 곳은 몇 군데 밖에 못 발견했다.      사이드 바의 카테고리 리스트 하이퍼링크.                     _includes/sidebar__categories.html           @@ -13,7 +13,7 @@ &lt;h3 class=\"nav__title\" style=\"padding-left: 0;\"&gt;     {% for category in categories %}     {% assign title = category[0] %}     {% assign posts = category[1] %} -   {% capture url %}/categories/{{ title }}{% endcapture %} +   {% capture url %}/categories/{{ title | slugify }}{% endcapture %}     &lt;li&gt;         &lt;a href=\"{{ url }}\"{% if url == page.url %} class=\"active\"{% endif %}&gt;         {{ title }}                           각 페이지의 Breadcrumbs 카테고리 하이퍼링크.                     _includes/breadcrumbs.html           @@ -1,6 +1,6 @@     {% case site.category_archive.type %}     {% when \"liquid\" %} -       {% assign path_type = \"#\" %} +       {% assign path_type = \"\" %}     {% when \"jekyll-archives\" %}         {% assign path_type = nil %}     {% endcase %}                   Breadcrumbs 는 조금 임시방편식으로 수정했다. 추후 기능 추가/제거 시 유의할 필요가 있다.                   GitHub Pages에 적용   나는 GitHub Pages를 이용하여 https://hepheir.github.io/에 블로그를 배포 하고 있다. 지금까지 만든 변경사항이 잘 적용되길 바라며 master 브랜치로 변경사항들을 Push하였다.   잠시 후, 정상적으로 Deploy가 완료되었다고 뜨길래 어디 카테고리 페이지들이 잘 만들어졌나 확인해보려 찾아보았으나, 그렇지 않았다. …어째서? ㅠㅠ   찾아보니 GitHub Pages의 자동 빌드를 사용하면 GitHub Pages가 지정한 특정 플러그인들을 제외하고는 적용되지 않는다고 한다. 이 문제를 해결할 방법으로 나는 두 가지 방법을 찾았다.      로컬 환경에서 직접 bundle exec jekyll build를 한 후, 빌드된 결과물을 업로드 하는 것.   GitHub Action을 통해 사용 플러그인에 제한이 없는 jekyll로 페이지를 빌드하도록 설정하는 것.   GitHub Action을 사용하여 빌드   그럼 바로 GitHub Action을 통해 Jekyll 사이트를 빌드하도록 설정해보자.      GitHub Action :: Jekyll Deploy Action   설치방법도 매우 간단하다. 다음의 파일을 새로 작성하면 된다.      .github/workflows/build-jekyll.yml   새로 만든 build-jekyll.yml을 푸쉬하고 경과를 지켜보면, 새로 생성된 build_and_deploy workflow에 의해 gh-pages라는 원격 브랜치가 새로 생성되고, 해당 브랜치에 빌드된 사이트가 있음을 확인 할 수 있다.   마지막으로, 레포지토리의 [Settings - Pages - Source]로 이동하여 GitHub Pages가 호스팅할 파일들이 위치한 Branch로 gh-pages를 지정해준다.   마무리   이로서 개별 카테고리 페이지를 자동으로 생성하는 소스코드를 추가하고 적용하는 일련의 과정이 끝났다. https://hepheir.github.io/ 에서도 개별 카테고리 페이지들이 정상적으로 출력되는 걸 확인했다. 이 포스트에서 다룰 내용은 여기서 잘 끝났다.  ","categories": ["Side Project","GitHub Blog"],
        "tags": ["Minimal Mistakes"],
        "url": "/side%20project/github%20blog/each-category-pages",
        "teaser": null
      },{
        "title": "Jekyll N Hyde를 만들며",
        "excerpt":"   “Jekyll N Hyde“는 Visual Studio Code 전용 확장 프로그램으로, Jekyll 을 사용하는 프로젝트에서 간결하게 포스트를 관리할 수 있도록 해주는 확장프로그램입니다.   » Jekyll N Hyde 저장소   » Jekyll N Hyde Microsoft 마켓플레이스   Jekyll   많은 Jekyll 사용자들은 카테고리 기능을 활용하고 있습니다. 머릿말의 category 혹은 categories 속성을 이용하면 포스트들을 체계적으로 관리할 수 있고, 독자들로 하여금 관심있는 주제의 포스트를 찾기 쉽게 해주죠. 하지만 블로그 관리자의 입장에서 보면, Jekyll 디렉터리 구조상에서 카테고리를 이용하여 post와 draft를 관리한다는 것은 상당히 번거로운 일입니다.   저 또한 Jekyll을 이용하는 GitHub Pages 블로그를 관리하면서 포스트를 관리하는 것이 굉장히 불편하다고 느꼈습니다. 때 마침, Visual Studio Code의 확장프로그램을 한 번 제작해보고 싶었기에 Jekyll의 포스트 관리 메커니즘을 편리하게 보강해줄 확장을 개발해보기로 하였습니다.   Jekyll N Hyde   VS Code의 Tree View API를 사용하여 다음과 같은 구조의 UI를 만들었습니다.      뷰에 가장먼저 카테고리 목록이 나타나고, 각 카테고리 노드를 클릭하여 펼치면 해당 카테고리에 속한 포스트가 나타납니다. 각 포스트는 해당 파일이 위치한 디렉터리가 _posts, _drafts인지에 따라 구분된 아이콘으로 표기됩니다.   마치며   깃허브 블로그를 운영하거나 시도 해본 사람이 많을거라 생각합니다. 일부는 Jekyll 혹은 Hexo, Hugo 등 정적사이트 생성기에 적응하여 잘 활용중이거나, 혹은 일부는 사이트 생성과정이 번거롭다고 생각하여 velog.io, tistory 등 다른 블로그 플랫폼으로 넘어가거나, 아예 블로깅을 그만두신 분들도 있을 것입니다.   저는 입문 난이도가 상대적으로 쉬운 Jekyll 기반 GitHub Pages 블로그가 더 활발해졌으면 좋겠습니다. 저 또한 Jekyll 기반 블로그 관리에 불편을 느껴 이탈을 고민한적도 있었죠. 그래서 “Jekyll N Hyde”를 만들었고, 이 VSC 확장이 Jekyll 사용자들이 블로그를 운영하는데 도움을 줄 수 있다면 좋겠습니다. Jekyll이 불편하여 이탈하는 사람들을 조금이나마 줄이는데 공헌했으면 좋겠다는 마음입니다.   현재 개선하거나 추가 해야할 기능들이 많이 있습니다. 그에비해 개발속도가 느려 이들을 빠르게 구현하지 못하고 있습니다. VS Code API나, TypeScript를 처음 써보고 있기에 기술 숙련도가 낮을 뿐더러, 프로젝트 초창기라 조금 더 설계에 신경을 쓰고 있기 때문에 다음 릴리즈까지는 조금 더 시간이 걸리지 않을까 생각합니다.   ","categories": ["Side Project","Jekyll n Hyde"],
        "tags": ["Jekyll N Hyde","Visual Studio Code","Visual Studio Code Extension"],
        "url": "/side%20project/jekyll%20n%20hyde/jekyll-n-hyde-0.0.1",
        "teaser": null
      },{
        "title": "1003번 - 피보나치 함수 (동적프로그래밍, 메모이제이션)",
        "excerpt":"2주차 알고리즘 수업 과제입니다.   “알고리즘 시간 복잡도 계산하기”   문제 링크   https://boj.kr/1003   입출력 및 제한사항           입력: 정수 $N$ 이 주어진다. (단, $0 \\leq N \\leq 40$)            출력: $N$번째 피보나치 수를 구하여 출력한다.            시간제한: 0.25초       풀이 :: $O(N)$   Memoization을 사용할 경우, 피보나치 수열은 시간복잡도 $O(N)$에 풀이가 가능합니다.   이 문제는 $n$번째 피보나치 수 $F_n$을 구하기 위해 $F_0$과 $F_1$이 얼마나 호출되었는지를 묻는 문제입니다.   피보나치 함수를 조금만 변형하면 풀이가 가능합니다.   $F_0$과 $F_1$의 호출 횟수를 저장하는 클래스 FibonacciCalledCount를 정의하여 문제를 풀이해보겠습니다.   from __future__ import annotations  from dataclasses import dataclass from functools import cache import sys   @dataclass class FibonacciCalledCount:     f0: int     f1: int      def __add__(self, other: FibonacciCalledCount) -&gt; FibonacciCalledCount:         return FibonacciCalledCount(self.f0 + other.f0, self.f1 + other.f1)      def __repr__(self) -&gt; str:         return f'{self.f0} {self.f1}'   @cache def fibonacci(n: int) -&gt; FibonacciCalledCount:     if n == 0:         return FibonacciCalledCount(1, 0)     elif n == 1:         return FibonacciCalledCount(0, 1)     return fibonacci(n-1) + fibonacci(n-2)   if __name__ == \"__main__\":     T = int(sys.stdin.readline())     for t in range(T):         N = int(sys.stdin.readline())         print(fibonacci(N))  ","categories": ["Algorithm","BAEKJOON Online Judge"],
        "tags": ["acmicpc.net","dynamic programming","memoization"],
        "url": "/algorithm/baekjoon%20online%20judge/boj-1003",
        "teaser": "https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/images/boj-og.png"
      },{
        "title": "15649번 - N과 M(1) (완전 탐색, DFS)",
        "excerpt":"2주차 알고리즘 수업 과제입니다.   “알고리즘 시간 복잡도 계산하기”   문제 링크   https://boj.kr/15649   시간 복잡도   $N$개의 자연수 중에서 서로 다른 M개의 수로 이루어진 수열을 뽑는 경우의 수는 $_NP_M$ 이다. 경우의 수가 곧 계산량 $T(N, M)$ 이 되므로, $O(_NP_M)$의 시간 복잡도를 갖게 된다.   \\[\\begin{align} T(N,M) &amp; = {}_{N}P_{M} \\\\ \\\\ &amp; = \\frac{N!}{M!} \\\\ \\\\ &amp; = N(N-1)(N-2)...(M+1) \\\\ \\end{align}\\]  문제의 조건에서 $N$과 $M$의 범위는 $1 \\leq M \\leq N \\leq 8$ 이다. 최악의 경우는 $N=8, M=1$ 일 때인데, 이 때의 계산량을 구해보면 $T(8, 1) = 8! = 40320$ 으로, 모든 경우의 수를 하나씩 보아도 충분히 시간 내에 풀 수 있을 것으로 보인다.   DFS   완전 탐색을 위한 다양한 알고리즘이 있는데, 상대적으로 구현이 쉬운 DFS로 풀이한다.   Stack을 이용하여 수열을 구성하는 수를 순서대로 저장하고, 재귀방식으로 수열의 다음 숫자를 선택해나아간다.   from typing import List   def solve(N: int, M: int):     _solve_w_dfs(N, M, [])   def _solve_w_dfs(N: int, M: int, stack: List[int]) -&gt; None:     if len(stack) == M:         print_answer(stack)         return     stack.append(-1)     for current_number in range(1, N+1):         if current_number in stack:             continue         stack[-1] = current_number         _solve_w_dfs(N, M, stack)     stack.pop()   def print_answer(sequence: List[int]):     print(' '.join(map(str, sequence)))   if __name__ == \"__main__\":     N, M = map(int, input().split())     solve(N, M)  ","categories": ["Algorithm","BAEKJOON Online Judge"],
        "tags": ["acmicpc.net","brute force","depth first search"],
        "url": "/algorithm/baekjoon%20online%20judge/boj-15649",
        "teaser": "https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/images/boj-og.png"
      },{
        "title": "2789번 - 블랙잭 (완전 탐색)",
        "excerpt":"2주차 알고리즘 수업 과제입니다.   “알고리즘 시간 복잡도 계산하기”   문제 링크   https://boj.kr/2798   풀이   3가지 수를 뽑는 모든 경우의 수를 탐색해봐야 한다.   서로 다른 n개의 카드 중에서 3개의 카드를 뽑는 경우의 수는 $_nC_3$ 이다. 경우의 수가 곧 계산량 $T(n)$ 이 되므로, $O(N^3)$의 시간 복잡도를 갖게 된다.   \\[\\begin{align} T(n) &amp; = {}_nC_3 \\\\ \\\\ &amp; = \\frac{n!}{3!(n-3)!} \\\\ \\\\ &amp; = \\frac{n^3-3n^2+2n}{6} \\\\ \\end{align}\\]  문제의 조건에서 카드의 개수 $N$의 범위는 $3 \\leq N \\leq 100$ 이다. 최악의 경우는 $N=100$ 일 때인데, 이 때의 계산량을 구해보면 $T(100) = 161700$ 으로 충분히 시간 내에 풀 수 있을 것으로 보인다.   from typing import List   def solve(N: int, M: int, C: List[int]) -&gt; int:     answer = 0     for i in range(N-2):         for j in range(i+1, N-1):             for k in range(j+1, N):                 sum_of_cards = (C[i]+C[j]+C[k])                 if sum_of_cards &lt;= M:                     answer = max(answer, sum_of_cards)     return answer   if __name__ == \"__main__\":     N, M = map(int, input().split())     C = list(map(int, input().split()))     print(solve(N, M, C))  ","categories": ["Algorithm","BAEKJOON Online Judge"],
        "tags": [],
        "url": "/algorithm/baekjoon%20online%20judge/boj-2798",
        "teaser": "https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/images/boj-og.png"
      },{
        "title": "현재 작업 영역 폴더 (Current Working Directory)",
        "excerpt":"확장 프로그램을 개발하다보니, 파일을 수정하고 관리하기 위해 Current Working Directory를 다룰 일이 많았다. 확장 프로그램을 개발하며 익힌 cwd와 관련된 노하우를 정리해보았다.   1. 골치 아픈 경로 두 가지   우선 확장프로그램 개발을 하면서, 초반에 두 가지 경로 때문에 골치가 아팠다.      확장프로그램이 설치된 경로   사용자가 작업중인 폴더 경로   위 두 가지 경로는 VS Code가 설치된 환경이나, 누가 사용중인지, 혹은 어떤 폴더를 열었는지 등에 따라 달라진다. 두 가지 경로만 확실하게 알 수 있다면, 나머지는 상대경로를 이용하여 처리하면 된다.   2. 확장프로그램이 설치된 경로를 구하는 방법   Visual Studio Code에서 확장프로그램이 실행될 때 entry point가 되는 함수는 일반적으로 src/extention.ts의 activate() 함수이다. activate() 가 호출 될 때, 첫 번째 인자로 ExtensionContext의 인스턴스를 전달받게 되는데, 바로 이 객체의 extensionUri 속성을 통해 확장프로그램이 설치된 경로를 Uri 형태로 얻을 수 있다.   import * as vscode from 'vscode';   export function activate(context: vscode.ExtensionContext) { \tconst extRootUri = context.extensionUri; }   2.1. Uri   Visual Studio Code 확장을 개발하다 보면, 어느 순간부터 파일이나 폴더의 경로를 string 으로 주고 받는 것 보다 Uri 형식으로 주고받게 되는 것 같다. 통합 자원 식별자(Universal Resource Identifier)인 만큼 범용성이 뛰어나고, 설령 string 형태의 경로가 필요하더라도 Uri 인스턴스의 path 나 fsPath 를 사용하면 된다. 게다가 Visual Studio Code API 중에 (특히 file system 관련해서) Uri 객체를 인자로 받는 메소드가 상당히 있기 때문에, Uri 사용에 익숙해진다면 확장프로그램 개발이 더욱 편해지는 것 같다.   2.2. Node.js의 __filename, __dirname   View와 관련된 객체를 구현하고 사용하다보면 아이콘이나, 문서의 locale 처리등을 위해 에셋을 사용해야 할 때가 있는데, 확장프로그램이 설치된 폴더의 경로를 구해야 할 때가 있다. ExtensionContext 를 알고있다면 extensionUri 를 사용하면 되지만, 그렇지 않다면 다른 방법을 통해 확장의 루트경로를 알아낼 수 있다.   Node.js의 __filename, __dirname와 함께 path 모듈을 사용하면 되는데, 작성중인 파일로 부터 루트까지의 상대경로와 __filename 혹은 __dirname 을 join 해주면 된다.   /**  * src/a/b/c.ts  */  import * as path from \"path\";   const root = path.join('..', '..', __dirname);   3. 열려있는 작업영역의 경로를 구하는 방법   3.1. workspace.rootPath   TypeScript를 사용하여 Visual Studio Code 확장을 개발하려면 npm의 vscode 라이브러리를 사용하게 되는데, cwd를 얻는 가장 쉬운방법은 workspace의 rootPath 속성을 사용하는 것이다.   rootPath는 Visual Studio Code에서 열려있는 (작업영역이라면 첫 번째인) 폴더의 경로를 string 타입으로 반환한다. 만약 폴더가 열려있지 않다면 undefined를 반환한다.   import * as vscode from \"vscode\";   if (vscode.workspace.rootPath === undefined) {     console.log('폴더가 열려있지 않음'); } else {     console.log('폴더가 열려있음', vscode.workspace.rootPath); }   하지만 rootPath는 deprecated 로, API 가이드에서는 rootPath 대신 workspace.workspaceFolders를 사용하라고 권장하고 있다.   3.2. workspace.workspaceFolders   아주 명료하게 string | undefined 형태로 경로를 전달해주는 rootPath 와 달리, workspaceFolders는 WorkspaceFolder[] | undefined 형태로 경로들을 전달해주는데, 조금의 처리를 거쳐 cwd를 얻을 수 있다.   » vscode.WorkspaceFolder 인터페이스 보기      하나의 폴더가 열려 있을 수도 있지만, 위와 같이 여러 폴더를 작업영역에 열어 둘 수 있다. workspace.workspaceFolders에는 이 열려있는 폴더에 대한 정보가 순차적으로 저장되어 있으므로, 아래와 같이 작업영역을 선택하여 사용하면 된다.   // vscode.Uri | undefined const rootUri = vscode.workspace.workspaceFolders &amp;&amp; vscode.workspace.workspaceFolders.length &gt; 0     ? vscode.workspace.workspaceFolders[0].uri     : undefined;  // string | undefined const rootPath = rootUri ? rootUri.fsPath : undefined;   [폴더 열기]를 통해 열 경우 workspaceFolders 의 첫 번째 원소에 정보가 저장되는데, [폴더 열기]와 [작업영역에서 열기] 모두에서 범용적으로 코드가 동작하도록 대체로 위와 같이 첫 번째 작업영역만을 사용하는 코드를 작성하여 쓰게 되는 것 같다.  ","categories": ["Side Project","Jekyll n Hyde"],
        "tags": ["Visual Studio Code"],
        "url": "/side%20project/jekyll%20n%20hyde/workspace-folder",
        "teaser": null
      },{
        "title": "Zero Width Space 문자와 해쉬",
        "excerpt":"유니코드 문자중에는 “제로 너비 공간”(Zero Width Space)이라는 문자가 있다. 참고로, 유니코드 번호는 U+200B이다.   \"\\u200B\"   JavaScript에서는 위와 같이 문자열에서 사용할 수 있는데, 상당히 쓸모가 많다.   같지만 다른 문자열   zws 문자를 사용하면, 겉보기에는 같으나 완전히 다른 문자열을 사용할 수 있다.   // \"==\" 연산자는 문자 구성이 같다면 true를 반환한다. console.log(\"hi\" == 'hi'); // true  // 화면에 출력되는 모습은 동일하다. console.log(\"hi\"); // hi console.log(\"\\u200Bhi\"); // hi  // 하지만 완전 다른 문자열이다. console.log(\"hi\" == '\\u200Bhi'); // false   제로 너비 공간과 Object (, 혹은 Dictionary) 자료형   JavaScript의 Object 자료형의 key 값으로 string 타입을 사용할 수 있는데, 동일한 문자열에 대해서는 항상 같은 value와 연결지어준다.   일례로, 아래의 'hi' 문자열과 \"hi\" 문자열은 서로 다른 줄에서 사용되는 리터럴이므로 각각의 레퍼런스는 다르나, 동일한 key 값에 접근하고 있음을 알 수 있다.   const obj = { hi: 1 };  console.log(obj['hi']); // 1  console.log(obj[\"hi\"]); // 1   그렇다면, zws 를 사용한 문자열은 어떻게 될까.   console.log(obj['\\u200Bhi']); // undefined   zws가 들어가게 되면 문자 구성이 달라지는 것이기 때문에 완전히 다른 문자열이된다. 이 원리를 이용하면 어플리케이션 개발을 할 때, 약간의 꼼수를 부릴 수 있다.   응용 사례   블로그 포스트를 카테고리 별로 그룹화하는 프로그램을 구현한 적이 있는데, 카테고리가 없는 포스트의 집합을 따로 구현해야할 필요가 있었다. 임시로 \"Uncategorized\" 라는 가상의 카테고리를 만들어서, 카테고리가 없는 포스트를 가상의 카테고리로 분류해두는 조치를 취했다.   하지만 위와 같이 조취를 취한다면 단점이 있다. “Uncategorized” 라는 이름의 카테고리가 존재한다면, “카테고리가 없는 포스트”와 “Uncategorized 카테고리에 해당하는 포스트”가 뒤섞이게 된다는 것이다.   이 때, ZWS 문자를 이용하여 위와 같은 상황을 회피하였는데, 임시로 만들 가상의 카테고리 이름을 \"\\u200BUncategorized\"로 사용한 것이다. 😆   import { Page } from \"jekyll\";  export type Categories = { [key: string]: Page[] };  export class CategoriesParser {     // Uses Zero-width space to distinguish uncategorized posts with posts in \"Uncategorized\"-category.     public static readonly UNCATEGORIZED = '\\u200BUncategorized';      static from(pages: Page[]): Categories {         const categories: Categories = { [this.UNCATEGORIZED]: [], };         pages.forEach(p =&gt; {             if (p.categories.length &gt; 0) {                 p.categories.forEach(categoryName =&gt; {                     if (categoryName in categories) {                         categories[categoryName].push(p);                     } else {                         categories[categoryName] = [p];                     }                 });                 return;             }             categories[this.UNCATEGORIZED].push(p);         });         return categories;     } }   » Jekyll-N-Hyde 프로젝트 보러가기  ","categories": ["Research","Others"],
        "tags": ["JavaScript"],
        "url": "/research/others/zero-width-space",
        "teaser": null
      },{
        "title": "YYYY-MM-DD 형식",
        "excerpt":"Jekyll 포스트 제목에는 YYYY-MM-DD 형식을 사용해야 해서, JavaScript의 Date의 날짜 포멧 관련 메소드를 찾아보았으나 없는 모양이다.   직접 만들어 쓰는 수 밖에. 🫠   현재 날짜로 만드는 YYYY-MM-DD   JavaScript의 Date 인스턴스에는 getFullYear(), getMonth(), getDate() 등의 메소드가 있다. 각각 년도, 월(0부터 시작, 0~11), 날짜를 숫자 형태로 반환한다.   이들을 적절히 이용하여 YYYY-MM-DD 패턴과 비슷한 문자열을 얻을 수 있다.   function getDateString(date=new Date(), delimiter='-') {     return [         (date.getFullYear()).toString(),         (date.getMonth()+1).toString(),         (date.getDate()).toString(),     ].join(delimiter); }   단, 위 경우에는 1999년 2월 13일을 예시로 들면, “1999-2-13”으로 ‘월’에 해당하는 자리가 두 자리로 출력되지 않는다. 날짜 또한 경우에 따라 마찬가지이므로, 결과적으로는 불완전한 YYYY-M-D 같은 형태가 될 수 있다는 점이 찝찝하게 남아있다.   // '월'이 한 자리로 출력되는 경우 &gt; getDateString(new Date(\"1999/2/13\")); '1999-2-13'  // '월'과 '날짜' 모두 한 자리로 출력되는 경우 &gt; getDateString(new Date(\"2022/4/1\")); '2022-4-1'   Zero Padding   원하는 길이의 데이터가 되도록, 원본 데이터의 앞에 0을 붙여주는 것을 zero padding 이라고 한다.   ‘년’, ‘월’, ‘일’에 해당하는 문자열이 각각 4, 2, 2의 길이가 되도록 zero padding을 하는 방법이 있는데, 바로 문자열의 padStart() 메소드를 이용하는 것이다.      padStart()는 문자열의 앞에 “원하는 문자”를 문자열이 “원하는 길이”가 되도록 붙여주는 메소드다.    function getDateString(date=new Date(), delimiter='-') {     return [         (date.getFullYear()).toString().padStart(4, '0'),         (date.getMonth()+1).toString().padStart(2, '0'),         (date.getDate()).toString().padStart(2, '0'),     ].join(delimiter); }   자, 그럼 실행결과를 보자.   // 현재 시간을 기준으로 출력하는 경우 &gt; getDateString(); \"2022-03-30\"  // 지정된 날짜를 출력하는 경우 &gt; getDateString(new Date(\"Sun Dec 1 2019 11:37:44\")); \"2019-12-01\"   이정도면 어느정도 만족할만한 결과가 나온 것 같다.   예외 처리      “Never Trust User Input”    “사용자 입력을 절대로 신뢰하지 마라 “라는 말이 있다.   자기가 만든 프로그램에 자신이 있고, 자기 혼자만 사용할 프로그램이라면 여기서 마무리 지어도 충분하나… 그런 이상적인 상황보다는 그러지 못한 상황이 더 많이 찾아오곤 한다.   함수나 메소드형태로 만든 것은 결국 또 다른 개발자가 사용가능 하도록 한 것인데, 특히 Type-Check를 하지 않는 JS에서는 모든 변수를 섣불리 신뢰하기는 어렵다. ㅋㅋ   아래와 같이 Date 객체 생성자에 넣는 값에 따라, 아래와 같이 유효하지 않은 Date 객체가 될 수 있다.   &gt;&gt;&gt; const date = new Date('');  &gt;&gt;&gt; date Invalid Date {}  &gt;&gt;&gt; date.getFullYear() NaN   getDateString()의 date 인자로 올바른 Date 객체가 주어질지 검사하는 로직을 추가하는 것이 좋을 것 같다. 검사 로직은 다음과 같이 2가지로 분리하여 작성하면 될 것 같다.      올바른 Date 객체인가?   유효한 Date 객체인가?   JavaScript 에서는 다음과 같이 표현할 수 있다.   // 올바른 `Date` 객체인가? &gt;&gt;&gt; date instanceof Date true  // 유효한 `Date` 객체인가? &gt;&gt;&gt; !isNaN(date.getTime()) true   최종 코드   Zero-Padding에 예외처리까지 곁들인 createDateFormat() 함수를 작성하면 아래와 같다.   JavaScript   function createDateFormat(date) {     if (!(date instanceof Date) || isNaN(date.getTime())) {         date = new Date();     }     return [         (date.getFullYear()).toString().padStart(4, '0'),         (date.getMonth() + 1).toString().padStart(2, '0'),         (date.getDate()).toString().padStart(2, '0'),     ].join('-'); }   TypeScript   /**  * Create date format in `YYYY-MM-DD` pattern.  *  * @param date  *  `Date` object used to generate year, month, and date.  *  If `date` is not given or invalid, `date` will be replaced with `new Date()`.  * @returns  */ function createDateFormat(date?: Date): string {     if (!(date instanceof Date) || isNaN(date.getTime())) {         date = new Date();     }     return [         (date!.getFullYear()).toString().padStart(4, '0'),         (date!.getMonth() + 1).toString().padStart(2, '0'),         (date!.getDate()).toString().padStart(2, '0'),     ].join('-'); }  ","categories": ["Research","Others"],
        "tags": [],
        "url": "/research/others/javascript-yyyy-mm-dd",
        "teaser": null
      },{
        "title": "내 ip 주소 알아내기 (IPv4)",
        "excerpt":"사실 다음의 명령어로 간단히 해결가능하다.   $ ifconfig   (Windows 라면 ipconfig)   물론, 아래와 같이 나온 정보들에서 찾아야 한다는 것이 흠이다.   lo0: flags=8049&lt;UP,LOOPBACK,RUNNING,MULTICAST&gt; mtu 16384         options=1203&lt;RXCSUM,TXCSUM,TXSTATUS,SW_TIMESTAMP&gt;         inet 127.0.0.1 netmask 0xff000000         inet6 ::1 prefixlen 128         inet6 fe80::1%lo0 prefixlen 64 scopeid 0x1         nd6 options=201&lt;PERFORMNUD,DAD&gt; gif0: flags=8010&lt;POINTOPOINT,MULTICAST&gt; mtu 1280 stf0: flags=0&lt;&gt; mtu 1280 anpi0: flags=8863&lt;UP,BROADCAST,SMART,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500         options=400&lt;CHANNEL_IO&gt;         ether d2:8d:4d:7a:d3:66         inet6 fe80::d08d:4dff:fe7a:d366%anpi0 prefixlen 64 scopeid 0x4         nd6 options=201&lt;PERFORMNUD,DAD&gt;         media: none         status: inactive anpi1: flags=8863&lt;UP,BROADCAST,SMART,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500         options=400&lt;CHANNEL_IO&gt;         ether d2:8d:4d:7a:d3:67         inet6 fe80::d08d:4dff:fe7a:d367%anpi1 prefixlen 64 scopeid 0x5         nd6 options=201&lt;PERFORMNUD,DAD&gt;         media: none         status: inactive ap1: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500         options=400&lt;CHANNEL_IO&gt;         ether a2:78:17:a5:8c:ef ...   grep   Linux 계열 OS에는 grep 이라는 프로그램이 있다. 이를 이용하면 정규표현식을 이용하여 문자열에서 원하는 패턴의 문자열을 찾을 수 있다.   macOS에는 기본적으로 2.6.0 버전이 설치되어있다.   $ grep --version # grep (BSD grep, GNU compatible) 2.6.0-FreeBSD   grep을 이용하여 개선해보기   ifconfig 의 출력을 보면, 대부분 ip 주소는 앞에 \"inet \"이 붙어있다. 이 패턴을 이용하여 출력을 간추려보자.   $ ifconfig | grep \"inet \" #         inet 127.0.0.1 netmask 0xff000000 #         inet 172.30.1.16 netmask 0xffffff00 broadcast 172.30.1.255   위의 결과에서 “127.0.0.1”은 Loopback ip 이므로 찾는 의미가 없다. 추론에 의해 “172.30.1.16”가 내가 찾는 ip 주소라는 것을 알 수 있다.   정규표현식으로 ip 주소만 추출하기   grep을 정규표현식과 함께 사용하면 활용도가 무긍무진하다. 정규표현식으로 ifconfig의 결과에서 ip 주소만 추출하는 것도 가능하다!   우선 정규표현식으로 ip 주소 패턴을 나타내면 다음과 같을 것이다:   [0-9]+\\.[0-9]+\\.[0-9]+\\.[0-9]+   여기서 정규표현식의 문자 클래스[]는 확장 정규표현식 문법이므로, grep에서 확장 정규표현식을 사용할 수 있게 해주는 -E 옵션을 사용해야 한다. 덤으로, -o 옵션을 사용하면 패턴과 일치하는 부분만 출력해준다.   $ ifconfig | grep \"[0-9]+\\.[0-9]+\\.[0-9]+\\.[0-9]+\" -E #         inet 127.0.0.1 netmask 0xff000000 #         inet 172.30.1.16 netmask 0xffffff00 broadcast 172.30.1.255  $ ifconfig | grep \"[0-9]+\\.[0-9]+\\.[0-9]+\\.[0-9]+\" -E -o # 127.0.0.1 # 172.30.1.16 # 172.30.1.255   ip 주소들만 골라 깔끔하게 출력했으나, 이 중 어떤 것이 진짜로 내가 찾는 ip 주소인지는 내가 직접 보고 선택해야한다.   (위에서 127.0.0.1는 루프백, 172.30.1.255는 게이트웨이이다.)   정규표현식 Lookahead 패턴   정규표현식을 깊게 파보면 Lookahead, Lookbehind 라는 패턴이 있다.                  Characters       Meaning                       x(?=y)                           Lookahead assertion: Matches \"x\" only if \"x\" is           followed by \"y\". For example, /Jack(?=Sprat)/ matches           \"Jack\" only if it is followed by \"Sprat\". /Jack(?=Sprat|Frost)/           matches \"Jack\" only if it is followed by \"Sprat\" or \"Frost\". However,           neither \"Sprat\" nor \"Frost\" is part of the match results.                                  x(?!y)                           Negative lookahead assertion: Matches \"x\" only if \"x\"           is not followed by \"y\". For example, /\\d+(?!\\.)/ matches           a number only if it is not followed by a decimal point. /\\d+(?!\\.)/.exec('3.141')           matches \"141\" but not \"3\".                                  (?&lt;=y)x                           Lookbehind assertion: Matches \"x\" only if \"x\" is           preceded by \"y\". For example,           /(?&lt;=Jack)Sprat/ matches \"Sprat\" only if it is           preceded by \"Jack\". /(?&lt;=Jack|Tom)Sprat/ matches           \"Sprat\" only if it is preceded by \"Jack\" or \"Tom\". However, neither           \"Jack\" nor \"Tom\" is part of the match results.                                  (?&lt;!y)x                           Negative lookbehind assertion: Matches \"x\" only if           \"x\" is not preceded by \"y\". For example,           /(?&lt;!-)\\d+/ matches a number only if it is not           preceded by a minus sign. /(?&lt;!-)\\d+/.exec('3')           matches \"3\". /(?&lt;!-)\\d+/.exec('-3') match is not           found because the number is preceded by the minus sign.                            » Mozilla JavaScript Guide - Regular Expressions 보기   상당히 유용한 패턴으로, Lookahead의 경우 “A앞에 있는 B” 만 골라서 찾는것이 가능하다.   이 패턴을 grep의 -o 옵션과 함께 활용하면 “A앞에 있는 B”에서 뒤따라오는 패턴인 “A”를 버리고 “B” 만 추출해내는 것이 가능하다. 말로 설명하기 어렵다. 예시를 보자:   // `\"Hi, I'm &lt;name&gt;.\"` 에서 `&lt;name&gt;`만 출력하는 패턴: // -&gt; \"Hi, I'm \" 뒤에 오고, \".\" 앞에 오는 길이가 1 이상인 모든 알파벳 // (?&lt;=Hi, I'm )\\w+(?=\\.)  &gt; \"Hi, I'm Hepheir.\".match(/(?&lt;=Hi, I'm )\\w+(?=\\.)/)[0] 'Hepheir'  &gt; \"Hi, I'm WakGood.\".match(/(?&lt;=Hi, I'm )\\w+(?=\\.)/)[0] 'WakGood'   Perl 정규표현식   위의 Lookahead, Lookbehind 와 같은 패턴은 확장 정규표현식이 아니라, Perl 언어에서 사용하는 정규표현식 패턴이다. grep에도 -P 옵션으로 Perl 정규표현식을 사용할 수 있는데, 아쉽게도 2.* 버전에서는 지원되지 않는다.   homebrew를 사용하여 grep을 업그레이드 해보자.   $ brew install grep  # ... # ==&gt; grep # All commands have been installed with the prefix \"g\". # ...   특이하게도 homebrew로 설치하면 명령어 이름앞에 \"g\"가 붙은형태로 설치가 된다. grep의 경우 ggrep으로 설치가 된 것이다.   $ ggrep --version # ggrep (GNU grep) 3.7 # Packaged by Homebrew # Copyright (C) 2021 Free Software Foundation, Inc. # License GPLv3+: GNU GPL version 3 or later &lt;https://gnu.org/licenses/gpl.html&gt;. # This is free software: you are free to change and redistribute it. # There is NO WARRANTY, to the extent permitted by law. # # Written by Mike Haertel and others; see # &lt;https://git.sv.gnu.org/cgit/grep.git/tree/AUTHORS&gt;.   3.7 버전의 grep(ggrep)이 설치되었으므로, 이제 Perl 정규표현식을 사용할 수 있을 것이다.   유효한 ip 주소만 추출   ifconfig의 출력을 보면, 유효한 ip 주소는 뒤에 “broadcast” 와 함께 게이트웨이 ip 주소를 보여준다. 이를 정규표현식으로 추출한다면, 다음의 패턴을 사용하면 될 것이다:   [0-9]+\\.[0-9]+\\.[0-9]+\\.[0-9]+(?=.+broadcast)   곧바로 적용하자.   $ ifconfig | ggrep \"[0-9]+\\.[0-9]+\\.[0-9]+\\.[0-9]+(?=.+broadcast)\" -P -o # 172.30.1.16   깔끔하게 원하는 결과가 나왔다.   … 그치만 명령어가 너무 길다. 편리함을 희생해 정확함을 얻기에는 트레이드 오프가 너무 심하지 않나 생각이 든다. 🫤   명령어 등록   이럴 때 쓰는 리눅스 명령어가 있다. alias 어떤 긴 것이라도, 단축어를 만들어주는 좋은 녀석이다.   새로운 명령어의 이름은 적당히 getip로 하자.   $ alias getip=\"ifconfig | ggrep \\\"[0-9]+\\.[0-9]+\\.[0-9]+\\.[0-9]+(?=.+broadcast)\\\" -P -o\"  $ getip # 172.30.1.16   이제 만족스러워졌다. 😎 👍  ","categories": ["Research","Others"],
        "tags": [],
        "url": "/research/others/getip",
        "teaser": null
      },{
        "title": "포스트 머릿말 빠르게 작성하기 (VS Code User Snippets)",
        "excerpt":"새로 포스트를 작성할 때 머릿말(Front Matter)을 작성하는 건 정말 번거롭습니다. 머릿말을 작성하는 것이 귀찮아서 완성되지 못하고 사라진 글감들이 제법 있는데, 이러한 고민을 Visual Studio Code의 사용자 코드조각으로 해결해보고자 합니다.      사용자 코드조각 (User Snippets)   사용자 코드조각은 미리 만들어둔 코드 패턴을 등록해두고, 필요할 때 빠르게 해당 패턴을 작성해주는 기능입니다.   Visual Studio Code 에서 사용자 코드조각을 편집하는 방법은 명령창(Cmd+Shift+P)에서 Preferences: Configure User Snippets 항목을 선택하면 됩니다.   Markdown 에서 사용자 코드조각 활성화   VS Code에서 Markdown 문서를 편집할 때, 사용자 코드조각이 나타나지 않는 경우가 있습니다. 설정에 다음 항목을 추가하여 사용자 코드조각을 사용할 수 있습니다.   // .vscode/settings.json  {     \"[markdown]\": {         \"editor.quickSuggestions\": true     } }   머릿말 작성을 위한 사용자 코드조각   --- prefix: title: &lt;커서위치&gt; categories: - tags: - date: YYYY-MM-DD hh:mm:ss +0900 ---   위와 같은 패턴을 생성하기 위한 사용자 코드조각을 작성해봅시다.   {     \"frontmatter\": {         \"prefix\": \"frontmatter\",         \"body\": [             \"---\",             \"prefix: \",             \"title: $0\",             \"categories:\",             \"- \",             \"tags:\",             \"- \",             \"date: $CURRENT_YEAR-$CURRENT_MONTH-$CURRENT_DATE $CURRENT_HOUR:$CURRENT_MINUTE:$CURRENT_SECOND +0900\",             \"---\"         ]     } }   사용된 변수는 아래의 문서를 참고하여 작성하였습니다.   » Visual Studio Code API - Snippets in Visual Studio Code  ","categories": ["Side Project","GitHub Blog"],
        "tags": ["Jekyll","Visual Studio Code","User Snippets"],
        "url": "/side%20project/github%20blog/quick-frontmatter",
        "teaser": null
      },{
        "title": "2661번 - 좋은수열",
        "excerpt":"https://boj.kr/2661   문제의 조건   신경 써야할 부분은 아래의 세 조건이다.      길이가 $N$인 수열 중 가장 작은 수열이어야 한다. $(N \\leq 80)$   좋은 수열이어야 한다.   단순하게 계산하기   완전탐색으로 모든 경우의 수를 확인하면 계산량이 어떻게 되나 알아보자.   모든 경우의 수 (Brute Force)   각 자리에는 1, 2, 3 중 하나만 올 수 있으므로, 길이가 $N$ 인 수열이 만들어지는 모든 경우의 수는 $3^{N}$이다.   이 때의 계산량 $T(N)$ 을 구해보면:   \\[\\begin{aligned} &amp; T(N)=3^N \\\\ \\\\ &amp; T(80)=1.4780883e+38 \\\\ \\end{aligned}\\]  최악의 경우에는 $1.4780883e+38$ 의 계산량을 갖게 된다.   연속하는 수를 배제   연속하는 수가 있으면 반드시 나쁜수열이므로, 연속하는 수가 나오는 경우를 배제해보자. 이때 나올 수 있는 경우의 수는 $3 \\times 2^{N-1}$이다. 이 때의 계산량 $T(N)$ 을 구해보면:   \\[\\begin{aligned} &amp; T(N)=3\\times2^{N-1} \\\\ \\\\ &amp; T(80)=1.8133887e+24 \\\\ \\end{aligned}\\]  목표 계산량 $1e+8$ 에 비해, 단순한 완전탐색으로는 도저히 풀 수 없어보인다. … 그럼 어떻게 풀어야 할까?   가장 작은 좋은 수열   문제에서 요구하는 정답은 가장 작은 좋은 수열이다. 즉, 수열을 오름차순으로 만들어나간다면 가장 먼저 나타나는 좋은 수열이 정답이 된다.   가능한 모든 수열을 오름차순으로 얻는 방법   완전탐색의 일종인 백트레킹으로 만들어 나갈 수 있을 것 같다.   아래와 같이 수열을 이룰 수 있는 숫자를 차례로 방문하면서 수열을 조합해나가는 것이다.   11223311112233&quot;111&quot;&quot;111&quot;&quot;112&quot;&quot;112&quot;&quot;113&quot;&quot;113&quot;&quot;12...&quot;&quot;12...&quot;&quot;12...&quot;&quot;12...&quot;Text is not SVG - cannot display  좋은 수열인지 검사하는 방법   수열 $a$ 에서 임의의 부분 수열 $(a_{s}, a_{s+1}, …,  a_{e-1})$ 에 대하여, 다음을 만족하면 이를 좋은 부분 수열이라고 하자.   \\[\\begin{aligned} &amp; \\text{let } mid = \\frac{s+e}{2} \\\\ &amp; \\text{if } (a_{s}, a_{s+1}, ...,  a_{mid-1}) \\neq (a_{mid}, a_{mid+1}, ...,  a_{e-1}) \\\\ &amp; \\text{then } a_{s...e} \\text{ is a good subsequence} \\end{aligned}\\]  임의의 수열 $a$ 가 좋은 수열인지를 검사하려면, 해당 수열에서 모든 짝수 길이의 부분 수열이 좋은 부분 수열인지 검사하면 된다.   예를 들어,           다음은 부분 수열 $(1,2,1,2)$ 가 좋은 부분 수열이 아니므로, 좋은 수열이 아니다.       1122121212121212121212131213221121213131112212121313331131312121113313131212221111221122113311221122Text is not SVG - cannot display           다음은 부분 수열 $(1,2,1,3,1,2,1,3)$ 이 좋은 부분 수열이 아니므로, 좋은 수열이 아니다.       1133131312121213121312131213221121213131112212121313331131312121113313131212221111221122113311221133Text is not SVG - cannot display           다음은 부분 수열 $(2,2)$ 가 좋은 부분 수열이 아니므로, 좋은 수열이 아니다.       2211212112121221122112131213222221213131112212121313331131312121113313131212221111221122113311222211Text is not SVG - cannot display           다음은 모든 부분 수열이 좋은 부분 수열이므로 좋은 수열이다.       3311313112121231123112131213223323233131112212121313331131312121113313131212221111221122113311223311Text is not SVG - cannot display      이 때의 계산량 $T(N)$ 을 구해보면 다음과 같다: ($2^{k}$는 부분수열의 크기이다.)   \\[\\begin{aligned} T(N) &amp; = \\sum_{k=1}^{log_{2}{N}} N-2^{k}+1 \\\\ \\\\ &amp; = \\frac{N \\log{N} - N \\log{4} + \\log{4 N}}{\\log{2}} \\\\ \\end{aligned}\\]  시간 복잡도   추산해보면 백트래킹 기법으로 길이가 $N$인 수열 $a$ 를 생성하는데에는 $O(2^N)$의 시간이 필요하고, $a$ 가 좋은 수열인지 검사하는데에는 $O(NlogN)$의 시간이 걸린다.   종합해보면 이 문제는 $O(2^{N}NlogN)$ 의 시간 복잡도를 가진다고 볼 수 있다.   최적화   다음은 $N = 8$ 일 때, 좋은 수열을 찾아 나가는 과정이다.   1122111111223311112211223311223311Text is not SVG - cannot display     아래로의 진행은 새로운 원소의 생성을 의미하고, 위로의 진행은 기존 원소의 제거를 의미한다. 붉은 색 노드는 해당 지점에서 좋은 수열이 아님을 의미한다.   여기서, 좋은 수열인지 검사를 하게 되는 시점을 보면 아래와 같다.   ・・・・・・Text is not SVG - cannot display     위 그림들을 통해 알 수 있는 것이 있다.      임의의 지점에서 좋은 수열이 아님을 알게되는 순간, 해당 지점에서 더 탐색해 나아갈 필요가 없다.   임의의 부분 수열에서 변화가 없다면, 해당 부분 수열은 다시 검사하지 않아도 괜찮다.  → 즉, 가장 마지막으로 갱신된 원소를 포함한 부분 수열만 좋은 부분 수열인지 검사하면 된다.   하지만, 여전히 이론상 최악의 시간복잡도는 $O(2^N N \\log{N})$ 이긴 하다. 과연 이 최적화로 인해 시간이 기적적으로 단축이 될까… 걸어보는 수 밖에 없다.   …   근데 귀신같이 통과되긴 했다. 매우 안정적으로. 🫠   코드 (Python3)   import sys from typing import List   def sample_in():     import io     sys.stdin = io.TextIOWrapper(io.BytesIO())     sys.stdin.write('\\n'.join([         '80',     ]))     sys.stdin.seek(0)   def solve():     N = int(sys.stdin.readline())     stack = []     backtrack(stack, N)   def backtrack(stack: List[int], sentinel: int) -&gt; bool:     if len(stack) == sentinel:         print(''.join(map(str, stack)))         return True     for i in (1,2,3):         stack.append(i)         if is_good(stack):             if backtrack(stack, sentinel):                 return True         stack.pop()     return False   def is_good(sequence: List[int]) -&gt; bool:     if len(sequence) &gt;= 2:         for subseq_size in range(2, len(sequence)+1, 2):             if not is_good_sub(sequence[-subseq_size:]):                 return False     return True   def is_good_sub(subsequence: List[int]) -&gt; bool:     assert len(subsequence) % 2 == 0     mid = len(subsequence) // 2     for i, j in zip(subsequence[:mid], subsequence[mid:]):         if i != j:             return True     return False   if __name__ == '__main__':     # sample_in()     solve()  ","categories": ["Algorithm","BAEKJOON Online Judge"],
        "tags": [],
        "url": "/algorithm/baekjoon%20online%20judge/boj-2661",
        "teaser": "https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/images/boj-og.png"
      },{
        "title": "Git Submodule을 이용한 Jekyll 블로그 테마와 포스트 분리",
        "excerpt":"     저는 GitHub Pages를 이용해서 hepheir.github.io를 배포하고 있습니다.   기존의 hepheir.github.io 레포지토리에서는 “블로그 테마/정보 수정”과 “포스트 작성/수정”이 동시에 이루어지고 있었습니다. 따라서 커밋 히스토리도 뒤죽박죽 엉망이라 관리가 어려웠죠.   서로 성격이 다른 두 작엄을 하나의 저장소에 처리하다보니 딜레마가 생겼었는데, hepheir.github.io 레포지토리는 공개하여 깃헙 프로필에 (pin📌 ) 해두고 싶지만, 작성중인 초안이나 일부 포스트는 비공개로 유지하고 싶었다는 것입니다.   레포지토리를 private으로 전환하지 못한 이유는 프로필에 핀 해두기 위해서도 있지만, 댓글 공급자로 사용중인 Utterances가 제대로 동작하기 위해서 레포지토리를 public으로 유지할 필요가 있기도 했습니다.   하지만 지난 주말, 열심히 고군분투한 끝에 posts 레포지토리와 theme 레포지토리를 분리해내는데 성공했습니다. 바로 git submodule을 이용해서 말이죠.   레포지토리 분리 계획      hepheir.github.ioJekyll PostsJekyll PostsJekyll ConfigJekyll ConfigJekyll ThemeJekyll Themehepheir.github.ioJekyll ConfigJekyll ConfigJekyll ThemeJekyll Themehepheir.github.io-postsJekyll PostsJekyll PostsText is not SVG - cannot display   레포지토리는 2개로 나누어, 위와 같이 책임을 분담시키기로 계획했습니다.   hepheir.github.io 레포지토리는 Jekyll 테마와 설정과 관련된 파일만 갖고, 그 외 포스트와 관련된 모든 항목은 hepheir.github.io-posts (private) 에서 다루는 것입니다.   새 리모트 레포지토리 생성   서브 모듈이 되어줄 새 레포지토리 hepheir.github.io-posts 부터 생성해보았습니다.   새로운 레포지토리의 주소는 다음과 같습니다.           HTTPS       https://github.com/Hepheir/hepheir.github.io-posts.git                SSH       git@github.com:Hepheir/hepheir.github.io-posts.git           새로 만든 레포지토리의 url을 미리 복사해둡니다.   커밋 히스토리 분리   블로그 설정・테마 관리용 레포지토리인 hepheir.github.io 에서는 포스트 작성・배포와 관련된 모든 작업을 일체 하지않는 것이 목적입니다. 이를 위해 기존 레포지토리에 존재하는 모든 포스트를 새로 만든 레포지토리로 이동시키기로 했습니다.   단순히 문서 파일들만 이동시키는게 아니라, 포스트 작성 과정이 담긴 기존의 커밋 히스토리 또한 새 래포지토리로 분리하고 싶었습니다. 다행히도 기존에 저만의 커밋 컨벤션을 지키며 커밋 히스토리를 관리하고 있었기에, git rebase -i 명령을 이용하여 비교적 쉽게 처리할 수 있었습니다.      post: 포스트 배포post: 포스트 배포config: 블로그 소개 수정config: 블로그 소개 수정draft: 새로운 초안 작성draft: 새로운 초안 작성draft: 초안의 카테고리 수정draft: 초안의 카테고리 수정post: 오타 수정post: 오타 수정theme: 카테고리 페이지 추가theme: 카테고리 페이지 추가theme: 포스트 제목 출력형식 변경theme: 포스트 제목 출력형식 변경origin/masterorigin/masterInitial commitInitial commitconfig: 블로그 ...config: 블로그 ...theme: 카테고리 ...theme: 카테고리 ...theme: 포스트 ...theme: 포스트 ...post: 포스트 ...post: 포스트 ...draft: 새로운 ...draft: 새로운 ...draft: 초안의 ...draft: 초안의 ...post: 오타 ...post: 오타 ...mastermasterpostspostsBefore RebaseBefore RebaseAfter RebaseAfter RebaseText is not SVG - cannot display   위와 같이 Rebase 하여 master, posts 브랜치로 커밋 그래프를 분리하고, posts 브랜치는 hepheir.github.io-posts로 push 한 뒤, 제거하였습니다.   이제 &lt;설정・테마 관리용 레포지토리&gt;와 &lt;포스트 작성・수정・배포 관리용 레포지토리&gt;가 분리되었습니다.   서브모듈 등록하기   git submodule 명령을 이용해 hepheir.github.io 레포지토리에 hepheir.github.io-posts 레포지토리를 서브모듈로 추가해 줄 것입니다.   Jekyll은 포스트를 _posts 디렉토리 아래에 보관하기 때문에, 아래처럼 서브모듈을 _posts 경로에 위치하도록 등록해주었습니다.   git submodule add \"https://github.com/Hepheir/hepheir.github.io-posts\" \"_posts\"   git submodule add 명령을 실행하면서 추가되면서 생성된 .gitmodules을 조금 수정하여, 새로 추가한 서브모듈이 자신의 master 브랜치와 동기화 될 수 있도록 다음과 같이 수정하였습니다.   [submodule \"_posts\"] \tpath = _posts \turl = https://github.com/Hepheir/hepheir.github.io-posts +\tbranch = master   이제 git submodule update --remote 명령을 이용하면, 서브모듈을 자동으로 (서브모듈의) master 브랜치와 동기화 할 수 있을 것입니다.   GitHub Action 수정하기   마지막으로 깃헙 페이지 배포 작업을 손보아야 합니다.   기존에는 hepheir.github.io의 master 브랜치에 새 push가 감지되면 자동을 빌드・배포가 이루어졌습니다. 하지만 이 방법은 이제 유효하지 않죠. 또한, hepheir.github.io 에서 빌드가 이루어지기 전 반드시 서브모듈을 최신화 해주어야 합니다. 만약 서브모듈이 private 레포지토리라면 접근권한 문제도 해결해야 합니다.   우선 private 서브모듈의 접근권한부터 획득해봅시다.   깃헙의 Settings &gt; Developer settings &gt; Personal access tokens 로 이동하여 새로운 토큰을 생성해주었습니다. 이 때, 최소로 요구되는 권한은 private 레포지토리에 대한 read 권한입니다. (read 만 주는 옵션은 없어서 Full control of private repositories로 주었습니다.)   여기서 생성한 PAT(Personal Access Token)을 GitHub Action 에서 사용할 수 있도록 hepheir.github.io에 등록할 것입니다. hepheir.github.io &gt; Settings &gt; Security &gt; Secrets &gt; Actions 로 이동하여 새로운 Repository Secret을 만들어 줍니다. 저는 아래와 같이 PRIVATE_REPO_ACCESS_TOKEN 이라는 이름으로 등록해주었습니다.          다음으로, 어떻게 자동으로 hepheir.github.io를 최신화 해줄 수 있을지가 관건입니다. 저는 큰 고민없이 매일 특정 시간에 자동으로 최신화 시도를 하도록 액션을 정의하는 방법을 택했습니다.   실제로 작성한 .github/workflows/build-jekyll.yml 을 보면 다음과 같습니다:   name: Build and Deploy to Github Pages  on:   push:     branches:       - master  # Here source code branch is `master`, it could be other branch   schedule:     - cron: '0 0 * * *' # Triggered at 00:00 GMT +0000 everyday. (09:00 for KST)    workflow_call:     secrets:       PRIVATE_REPO_ACCESS_TOKEN:         # https://github.com/Hepheir/hepheir.github.io/settings/secrets/actions         # Add a secret named \"PRIVATE_REPO_ACCESS_TOKEN\" on the link above.         description: 'A Personal Access Token which can access to private repositories'         required: true  jobs:   build_and_deploy:     runs-on: ubuntu-latest     steps:       - name: Checkout         uses: actions/checkout@v2         with:           token: ${{ secrets.PRIVATE_REPO_ACCESS_TOKEN }}           submodules: true        - name: Login as github-actions bot         run: |           git config user.name 'github-actions[bot]'           git config user.email 'github-actions[bot]@users.noreply.github.com'        - name: Update submodule         run: |           git submodule update --remote        - name: Apply update to master         continue-on-error: true         run: |           git commit -am \"chore(_posts): merge submodules into master            [skip actions]\"           git push origin master        # Use GitHub Actions' cache to cache dependencies on servers       - name: Cache dependencies         if: ${{ success() }}         uses: actions/cache@v2         with:           path: vendor/bundle           key: ${{ runner.os }}-gems-${{ hashFiles('**/Gemfile.lock') }}           restore-keys: |             ${{ runner.os }}-gems-        # Use GitHub Deploy Action to build and deploy to Github       - name: Build jekyll pages         if: ${{ success() }}         uses: jeffreytse/jekyll-deploy-action@v0.3.1         with:           provider: 'github'           token: ${{ secrets.GITHUB_TOKEN }} # It's your Personal Access Token(PAT)           repository: ''             # Default is current repository           branch: 'gh-pages'         # Default is gh-pages for github provider           jekyll_src: './'           # Default is root directory           jekyll_cfg: '_config.yml'  # Default is _config.yml           jekyll_baseurl: ''         # Default is according to _config.yml           bundler_ver: '&gt;=0'         # Default is latest bundler version           cname: ''                  # Default is to not use a cname           actor: ''                  # Default is the GITHUB_ACTOR           pre_build_commands: ''     # Installing additional dependencies (Arch Linux)   마무리   이렇게 지난 주, 제가 어떻게 Jekyll 을 사용하는 GitHub Pages의 포스트 레포지토리를 private 레포지토리로 분리해냈는지를 정리해보았습니다.   이제, 다른 사람들은 빌드된 사이트를 통해 제가 배포하기로 결정한 포스트만 볼 수 있고, 작성중인 초안은 공개되지 않은 채 hepheir.github.io-posts 에서 은밀하게 작성되어지겠죠! 하하! 😎   ","categories": ["Side Project","GitHub Blog"],
        "tags": [],
        "url": "/side%20project/github%20blog/make-posts-private",
        "teaser": null
      },{
        "title": "자바 로또 프로젝트",
        "excerpt":"         이번 구현 과제에서는 두 가지 요소에 집중했습니다.      SRP 지키기   Interface(Java)를 이용한 프로그래밍   SRP 지키기   SRP(Single Responsibility Princible, 단일 책임 원칙)이란, 객체 지향 프로그래밍에서 모든 클래스는 하나의 책임만 갖고, 클래스가 제공하는 모든 기능은 이 책임과 관련이 있어야 함을 일컫는 것입니다.   지금까지 구현 과제들을 수행해오면서, SRP를 모른 채로 프로그램의 의존성 구조를 설계해보고, 각 클래스 별로 책임을 분배하는 과정에서, 각 클래스별로 책임을 적게 주는 것이 좋은 것임을 몸소 깨우쳤던 것 같습니다.   최근에 이를 SRP라고 일컫는다는 것을 알게되었고, 이번 과제를 구현하면서 SRP를 지켜보자고 다짐을 해보았습니다.   책임을 나눈다는 것   SRP를 고려하지 않는다면, 자칫 아래와 같이 하나의 클래스에 여러 개의 책임을 지우게 되는 실수를 할 수 있습니다.      6개 이하의 1~45 범위 숫자들로 이루어짐을 보장하는 책임6개 이하의 1~45 범위 숫자들로 이루어짐을 보장하는 책임LotteryTicketLotteryTicketText is not SVG - cannot display   예시 속의 두 책임은 얼핏 보면 “6개 이하의 1~45 범위 숫자들로 이루어짐을 보장하는 책임”으로 단일 책임 같아 보일 수도 있습니다. 하지만, 충분히 다음과 같이 좀 더 세분화 할 수 있죠.      1~45 범위의 숫자임을 보장하는 책임1~45 범위의 숫자임을 보장하는 책임6개 이하의 숫자들로 이루어짐을 보장하는 책임6개 이하의 숫자들로 이루어짐을 보장하는 책임LotteryTicketLotteryTicketText is not SVG - cannot display   이 때, LotteryTicket은 두 개의 책임을 지고 있는 것이 되므로, 이는 SRP에 위배됩니다. 이 때는, 아래와 같이 별도의 클래스를 설계하여 책임을 전가하는 것으로 개선할 수 있겠네요.      1~45 범위의 숫자임을 보장하는 책임1~45 범위의 숫자임을 보장하는 책임6개 이하의 숫자들로 이루어짐을 보장하는 책임6개 이하의 숫자들로 이루어짐을 보장하는 책임LotteryTicketLotteryTicketLotteryNumberLotteryNumberText is not SVG - cannot display   앞으로는 어떠한 책임 단위를 나눌 때, “혹시 더 세부적인 책임으로 쪼개질 여지가 있는지“를 면밀히 검토해봐야 할 것 같습니다.   Interface(Java)를 이용한 프로그래밍   인터페이스는 구현을 하지 않은채로 사용하는 자료형입니다. 설계 단계에서는 인터페이스에 변경사항이 생겨도, 메소드의 추가・제거, 시그니쳐의 변경정도만 하면 되므로 수정에 많은 시간이 소요되지 않는다는 것이 장점입니다.   이전까지의 구현 과제들은 전체적인 구조가 잡힐 때 까지 대략 3~5일이 걸리곤 했는데, 시간이 많이 걸렸던 이유는 여러 클래스들에 대해 “설계 → 구현 → 적용 → 수정”의 복잡한 절차를 거쳐가야했기 때문입니다.   특히, 구현과 적용에 있어, 변경 사항의 전파를 따라 수정사항을 차례로 적용하는 것과, 이에 따라오는 디버깅 과정이 상당히 많은 시간을 필요로했죠.   인터페이스만 작성하여 전체적인 구조를 먼저 잡는 방법을 택하면서, 지난 과제들에 비해 코드 수정이 적어졌다는 것을 확실하게 체감할 수 있었고, 구조 또한 만족스러운 형태로 잡혔다는 느낌이 들었습니다.   인터페이스에서는 구현을 생략한다고요?   인터페이스는 Java의 List 처럼, 대략적인 인터페이스의 사용 방법과, 각 메소드가 수행할 것으로 예상되는 동작들을 설명해주는 것으로 끝납니다.   실제로 코드를 동작시키려면 List와 동일한 인터페이스를 갖는 구현체 ArrayList나 LinkedList 등의 도움을 받아야하죠.   예를 들어 다음의 코드는 정수 리스트를 서로 다른 구현체로 생성하는 예시입니다.   List&lt;Integer&gt; list1 = new ArrayList&lt;&gt;(); List&lt;Integer&gt; list2 = new LinkedList&lt;&gt;();  list1.add(1); list2.add(1);   두 객체 list1, list2 에서 모두 List 인터페이스가 명시한 add(), remove(), size() 등과 같은 메소드를 제공합니다. 하지만, 두 객체는 서로 다르게 구현되었기에, 연산 종류에 따라서 시간복잡도가 달라지기도 하죠.   ArrayList와 LinkedList의 차이에 대해 더 알아보고 싶다면, 다음의 글을 추천합니다. » 자료구조: Linked List 대 ArrayList   Interface와 SRP를 활용해봅시다   다음은 복권 한 장을 생성하거나, 복권에 들어갈 숫자를 생성해주는 인터페이스 Driver입니다. Driver는 적절한 Builder와 Supplier를 입력받아 타깃이 되는 객체를 안정적으로 생성해주는 책임을 지고 있습니다.   package domain;  public interface Driver {     public LotteryTicket createLotteryTicket(LotteryTicketBuilder ticketBuilder, LotteryNumberSupplier numberSupplier);      public LotteryNumber createLotteryNumber(LotteryNumberSupplier numberSupplier); }   복권을 생성하는 과정에서의 책임 분배에 대하여   LotteryTicket createLotteryTicket(     LotteryTicketBuilder ticketBuilder,     LotteryNumberSupplier numberSupplier)   createLotteryTicket() 메소드를 보면, 인자로 LotteryTicketBuilder와 LotteryNumberSupplier를 받고있습니다. 두 객체는 각각 다음의 책임이 있죠.      LotteryTicketBuilder: LotteryNumber를 입력받아 LotteryTicket 을 안정적으로 생성하는 책임.   LotteryNumberSupplier: LotteryNumber를 안정적으로 공급하는 책임.   왜 이렇게 책임이 분배되어있나요   LotteryTicketBuilder에서는 이미 보장된 숫자를 입력받지, 자신이 해당 숫자가 복권에서 사용가능한지 검사하지는 않습니다. 만약 숫자의 범위까지 LotteryTicketBuilder에서 검사하게 된다면 SRP에 위배되니깐요.   그럼 숫자의 보장은 어디서?   LotteryNumber는 복권에서 사용할 수 있는 범위의 숫자임을 보장하는 객체입니다. 따라서, LotteryNumber를 안정적으로 공급해주는 책임이 있는 객체가 필요합니다. 그래서 인자로 LotteryNumberSupplier를 받게 되어있죠.   숫자를 공급받는 방법에 대하여   LotteryNumberSupplier에게는 숫자(LotteryNumber)를 안정적으로 공급할 책임이 있지만, 어떻게 숫자를 생성할지까지 정의하지 않았습니다. List 를 구현하기 위한 방법으로 ArrayList 와 LinkedList 가 있는 것처럼, 구현은 사용자의 몫입니다.   본 과제의 내용을 보면, 두 가지 방법으로 복권의 숫자 조합을 결정할 수 있어야합니다. 자동으로 생성하거나, 직접 입력하는 것입니다. 각각의 구현체를 만들어 아래와 같이 사용할 수 있도록 구현할 수 있습니다.   Driver driver = new ConcreteDriver(); LotteryNumberSupplier manualNumberSupplier = new ManualLotteryNumberSupplier(); LotteryNumberSupplier autoNumberSupplier = new AutoLotteryNumberSupplier();  // 직접 수동으로 숫자를 입력하여 복권 발급. driver.createLotteryTicket(ticketBuilder, manualNumberSupplier);  // 숫자를 자동으로 생성하여 복권 발급. driver.createLotteryTicket(ticketBuilder, autoNumberSupplier);   ManualLotteryNumberSupplier은 사용자 입력을 안정적으로 받아오는 책임이 있는 Controller로 부터 숫자 입력을 받아와 LotteryNumber를 발급하고, AutoLotteryNumberSupplier는 미리 1~45의 숫자를 Stack에 push 해두고 shuffle 한 뒤, pop 해가며 LotteryNumber를 중복없이 공급합니다.   마무리   확실히 지난 과제에 비해 구현과 수정, 리펙터링에 소요되는 시간이 확연히 줄었습니다. 인터페이스를 이용하여 설계하는 것은 시간적 측면에서 확실히 이점이 있다고 느낍니다. 하지만 단점 또한 존재하는데, 설계를 마친 인터페이스에 대해 구현체가 생기기 시작하면 점점 수정이 어려워진다는 점이 있습니다. 그만큼 설계를 치밀하고 신중하게 해야할 필요가 있다는 것이겠죠.   모든 것에는 Trade-off 가 있다고 합니다. 유지보수적인 측면에서 인터페이스를 사용할 때의 득실을 따져보면, 이번 과제를 통해 저는 득이 실보다 훨씬 크다고 생각하게 되었습니다. 하하!   전체 코드는 이 곳(PR) 혹은 이 곳(Forked Repository)에서 볼 수 있습니다.  ","categories": ["Note","Java & Spring & Algorithm"],
        "tags": [],
        "url": "/note/java%20&%20spring%20&%20algorithm/java-lotto-implementation",
        "teaser": null
      }]
